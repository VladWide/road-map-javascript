Главная > Курсы > JavaScript > Объекты — прототипы
Объекты JavaScript — прототипы
Что вы узнаете на этой странице?
Резюме проблемы с определением методов в теле конструктора
Что такое прототипы
Внутренний [[Prototype]]атрибут
Метод Object.create()\_
Цепи прототипов
Механизмы поиска и присвоения свойств
Собственные и унаследованные свойства
Внутренняя работа inоператора
Свойство prototypeфункций
Прототипное наследование
Получение прототипов через Object.getPrototypeOf()и**proto**
Настройка прототипов через Object.setPrototypeOf()и**proto**

Объекты
Викторина конструкторов
Объекты
Викторина по прототипам

Вступление
В последней главе о конструкторах мы увидели приличное количество концепций, связанных с основной концепцией функции-конструктора в JavaScript. В частности, мы увидели, что такое конструкторы; как их создать; как из них инициализировать объекты; проверить наличие экземпляров конструктора и т.д. и т.п.

Там мы даже столкнулись с тем фактом, что определение методов экземпляра внутри тела функции-конструктора, как правило, не очень хорошая идея, и что лучший способ создать метод экземпляра — использовать прототип .

Так что же такое прототип в JavaScript?

Эта глава призвана ответить на этот вопрос в самой его сути и в мельчайших деталях.

К концу этой главы вы гарантированно будете знать понятие прототипа, когда его использовать, как его использовать, многие связанные с ним термины, такие как унаследованные свойства , и многое другое.

Ладно, пора нырять прямо в...

Определение методов внутри конструкторов
Прежде чем мы начнем, давайте быстро вспомним проблему с определением метода экземпляра в теле функции-конструктора. Это позволит нам лучше оценить значение прототипов.

Ниже показан фрагмент кода, который мы написали в предыдущей главе:

function Point(x = 0, y = 0) {
this.x = x;
this.y = y;

    this.setTo = function(x, y) {
        this.x = x;
        this.y = y;
    }

}
Можете ли вы вспомнить проблему здесь?

Ну, setTo()это метод, который просто перемещает данный Pointэкземпляр в другой набор координат. Он ведет себя одинаково для каждого Pointэкземпляра, но наш код создает новый setTo()метод для каждого нового экземпляра.

То есть, если у нас есть десять Pointэкземпляров, то каждый из них имеет свой собственный setTo() метод, что составляет всего десять различных setTo()методов в приложении (все делают одно и то же)!

Это проблема. Мы повторяем вещи.

Вспомните, что мы предотвратили создание этой повторяющейся функции, определив функцию один раз в глобальной области видимости, а затем назначив ее this.setToвнутри конструктора, но у этого были и свои недостатки.

Во-первых, для каждого экземпляра по-прежнему существует отдельное setToсвойство, даже если оно содержит одну и ту же создаваемую функцию; во-вторых, глобальная область видимости теперь загрязняется.

Мы даже заложили пару решений этой проблемы глобального масштаба-загрязнения, но все они вели только к одному пути, и это было большей головной болью.

Подробнее об этих проблемах читайте в разделе « Проблема с конструкторами» в последней главе « Объекты JavaScript — конструкторы» .
Короче говоря, самый простой и эффективный способ создания методов экземпляра в JavaScript — это воздержаться от использования тела функции-конструктора (почти во всех случаях) и вместо этого использовать прототипы.

Давайте исследуем их...

Что такое прототип?
JavaScript, как мы уже знаем, является объектно-ориентированным языком программирования. По сути, он построен на идее объектов.

Теперь языки ООП можно разделить на две категории: классические языки ООП (также известные как языки на основе классов), например, C++, Java, Python; и прототипные языки ООП (также известные как языки на основе прототипов) для, например, Self, JavaScript.

Как известно, JavaScript — это язык ООП, основанный на прототипах.

В классических языках ООП классы наследуют данные от других классов. Объекты-экземпляры, созданные из этих классов, по существу не наследуют данные от других объектов.

В языках, основанных на прототипах, понятие наследования, безусловно, присутствует, но по-другому. В этих языках не просто существуют классы, поэтому нет смысла думать о том, что с ними происходит.

В языках на основе прототипов объекты наследуют данные от объектов .

Это приводит нас к простейшему определению того, что такое прототип:

Для данного объекта oобъект, от которого наследуются свойства , называется прототипом .o o
Вот именно!

Как всегда, давайте разберемся с этим определением подробнее.

Если мы рассмотрим любой заданный объект o, скажем, массив [1, 2, 3]или объект {x: 0, y: 0}, то объект, от которого oнаследуются свойства, называется прототипом o.

Предположим, что pэто объект-прототип. Тогда любые свойства, определенные для p, также будут доступны для , oпоскольку они наследуются .o

Но что именно означает «наследует» в контексте объектов в JavaScript?

Формальное определение «наследования» по отношению к объектам JavaScript прямо сейчас было бы скорее жаргоном, чем подсказкой, поэтому мы продемонстрируем простой пример, чтобы объяснить это.

Допустим, у нас есть два объекта aи b, как показано ниже:

var a = { x: 10, y: 20 };
var b = { p: 100, q: 200 };
Если мы предположим, что aэто прототипb , который никак явно не показан в этом фрагменте кода (т. е. это просто предположение), то вот что произойдет, когда мы получим доступ к паре свойств в b.

b.pпросто было бы 100.
b.qбыло бы 200.
b.xбыло бы... Хм. Что вы думаете? Ну, b.xбыло бы, 10и вы, возможно, уже смогли увидеть, откуда берется это значение — оно наследуется от a.
b.yбудет 20, еще раз благодаря наследованию.
По сути, это и есть прототипы — то есть наследование. Один объект имеет доступ ко всем свойствам своего прототипа посредством наследования.

Вот и все!

В прототипах в JavaScript нет ничего сложного, о чем вы, возможно, подумали, просматривая онлайн-ресурсы, обучающие прототипам, или от ваших коллег-разработчиков.

Прототипы невероятно просты, и это факт!

А вот приложения прототипов в JavaScript, плюс парочка утилит, которые вокруг них вращаются, и вовсе не так просты для понимания на первый взгляд — они требуют чуть большего внимания.

Но не беспокойтесь. Мы обсудим все и вся простыми словами, чтобы убедиться, что вы закончите эту главу как профессионал прототипа .

Давайте узнаем больше о прототипах в JavaScript...

[[Prototype]]Атрибут \_
До сих пор мы узнали, что объект в JavaScript наследует данные от другого объекта, называемого его прототипом. Справедливо.

Но давайте остановимся здесь на мгновение и еще раз подумаем об этом определении.

Объект наследует данные от своего прототипа. ХОРОШО.

Но откуда он вообще узнает о своем прототипе? Другими словами, как любой данный объект узнает, что он будет наследовать свойства от другого данного объекта?

Что ж, это действительно хорошее наблюдение. И хорошая новость заключается в том, что ответ довольно прост.

Оказывается, в JavaScript, как указано в разделе 10.1 спецификации ECMAScript , каждый отдельный объект (да, верно, каждый отдельный объект) имеет внутренний атрибут с именем [[Prototype]], который просто содержит ссылку на прототип этого объекта.

Каждый объект в JavaScript имеет внутренний [[Prototype]]атрибут, который содержит ссылку на его прототип .
Проще говоря, все объекты в языке наследуют свойства своего [[Prototype]]атрибута, который просто указывает на их объект-прототип.

Легкий?

Вернемся к нашему старому примеру с объектом aи bследующим образом:

var a = { x: 10, y: 20 };
var b = { p: 100, q: 200 };
где bпрототип a, внутренне объект bбудет выглядеть примерно так:

// internal representation of b
b: {
p: 100,
q: 200,
[[Prototype]]: a
}
Сначала он содержит свои собственные свойства, pа qзатем внутренний атрибут [[Prototype]], указывающий на его прототип, которым в данном случае является a.

Рассмотрим более знакомый пример.

Мы все привыкли создавать массивы и литеральные объекты из предыдущей части этого курса.

В тот момент, когда мы создаем массив, используя литеральную нотацию []или Array()конструктор, JavaScript создает Arrayэкземпляр, прототип которого настраивается автоматически.

Например, учитывая массив arrниже:

var arr = [10, -5, 60];
если бы нам нужно было показать его внутреннее представление, оно было бы следующим:

// internal representation of arr
arr: {
0: 10,
1: -5,
2: 60,
length: 3,
[[Prototype]]: Array.prototype
}
Это не полная иллюстрация всех внутренних атрибутов массива или объекта в целом. На данный момент нас интересует только [[Prototype]]это и, следовательно, мы демонстрируем это только для простоты.
Первые три свойства — это просто элементы массива, четвертое свойство — lengthэто массив, и, наконец, последнее — его внутреннее свойство [[Prototype]], содержащее прототип объекта массива.

Этот прототип оказывается Array.prototypeсобственностью prototypeконструктора Array.

Позже в этой главе мы увидим всю идею prototypeсвойства функций-конструкторов и то, как оно позволяет JavaScript эмулировать классы из классических языков ООП, а также понятие самих функций-конструкторов.

Рассмотрим другой пример.

Когда мы создаем объект с помощью синтаксиса литерала объекта или, что то же самое, с помощью Object()конструктора, JavaScript создает Objectэкземпляр, прототипу которого автоматически присваивается значение Object.prototype:

Следовательно, учитывая приведенный ниже код:

var obj = { x: 0, y: 0 };
его внутреннее представление будет примерно следующим:

// internal representation of obj
obj: {
x: 0
y: 0,
[[Prototype]]: Object.prototype
}
Объект objбудет иметь доступ ко всем свойствам, определенным в Object.prototype.

Далее в этой главе мы еще раз Object.prototypeрассмотрим свойства конструкторов в целом.prototype

Короче говоря, у каждого отдельного объекта в JavaScript есть соответствующий прототип, от которого он наследует свойства, и этот прототип хранится во внутреннем [[Prototype]]атрибуте этого объекта.

Простой!

Теперь иногда может случиться так, что объект не хочет наследовать какие-либо свойства от другого объекта. Другими словами, может случиться так, что объект не хочет иметь прототип.

Но это кажется невозможным, потому что каждый объект в JavaScript обязан иметь прототип. Что теперь?

Что ж, решение довольно простое — у объекта есть свой прототип в виде null.

Прототип фактически все еще присутствует в объекте, т. е. его [[Prototype]]атрибут имеет значение в конце дня, но это nullсигнализирует о том, что объект не наследует никаких свойств.

В JavaScript есть только один предопределенный объект, у которого есть nullпрототип, и это Object.prototype.

Однако, как мы увидим в следующем разделе, мы можем создать любой пользовательский объект с nullего прототипом.

[[Prototype]]это просто спецификация !
Обратите внимание, что это обозначение [[Prototype]]является просто воображаемой идеей, предназначенной исключительно для пояснительных целей — на самом деле ничего подобного нет [[Prototype]]в реализациях JavaScript.

Все основные реализации, в том числе в Google Chrome, Firefox, Safari, Edge и т. д., имеют сложные способы разрешения прототипа любого произвольного объекта среди многочисленных оптимизаций. Способ, которым каждая из этих реализаций хранит эти ссылки на прототипы, является чисто локальным для самой соответствующей реализации.

Спецификация ECMAScript использует эту нотацию внутренних атрибутов (т. е. ), чтобы иметь возможность легко и ясно объяснять вещи — движки JavaScript могут свободно использовать любой способ реализации этих вещей, при условии, что они остаются совместимыми с поведением, определенным в спецификации.[[InternalAttribute]]

Метод Object.create()\_
В примере, приведенном в разделе « Что такое прототип » выше, где мы определили два литерала объекта aи b, мы предположили, что aэто прототип b— в самом коде не было ничего, что фактически это реализовывало.

Теперь, используя метод Object.create(), мы фактически построим это отношение прототипа между aи b.

Статический Object.create()метод был введен в ECMAScript 5 как способ создания нового объекта с заданным прототипом.
Вот его синтаксис:

Object.create(prototype[, propsObj])
Прототип создаваемого объекта указывается в качестве первого аргумента для Object.create().

Второй propsObjаргумент указывает начальные свойства создаваемого объекта. Как можно подумать, этот аргумент не является объектом, отображающим ключи в значения, а скорее объектом, отображающим ключи в дескрипторы свойств. Мы увидим, что это означает, в главе « Методы объекта JavaScript» .

Второй параметр Object.create()не очень часто используется.
В следующем упражнении мы попросим вас реализовать полифилл Object.create()исключительно для использования идеи функции-конструктора.

В любом случае, давайте теперь приступим Object.create()к делу.

Во-первых, давайте рассмотрим объект a, который должен быть прототипом b:

var a = { x: 10, y: 20 };
Теперь рассмотрим объект b:

var b = { p: 100, q: 200 };
Еще раз повторяю, aнужно сделать прототип b. В настоящее время в коде ничего не реализовано.

Как вы думаете, как это можно сделать с помощью Object.create()?

Что ж, здесь нужно понять одну вещь: мы хотим изменить прототип существующего объекта ( bв данном случае). Однако Object.create()только позволяет нам создать новый объект с заданным прототипом.

Следовательно, мы не могли просто взять bи волшебным образом установить aего в качестве прототипа, используя Object.create(). Просто нет способа сделать это, по крайней мере, с помощью Object.create().

Вместо этого мы должны сначала создать пустой объект, используя Object.create()прототип которого настроен на a, сохранить этот объект в b, а затем добавить свойства, bкак указано в приведенном выше коде, одно за другим, используя присваивание свойства записи через точку (или скобки). синтаксис.

Давайте посмотрим на это с точки зрения кода:

var a = { x: 10, y: 20 };

// make a as the prototype
var b = Object.create(a);

// add the properties one-by-one
b.p = 100;
b.q = 200;
Вот что происходит в этом маленьком фрагменте кода:

Прежде всего создается глобальная переменная aи ей присваивается объект { x: 10, y: 20 }. Далее создается глобальная переменная b, которой присваивается значение Object.create(a). Этот вызов метода эффективно создает новый пустой объект, прототип которого имеет значение a.

Наконец, мы добавляем два свойства pи qк bи устанавливаем их в 100и 200соответственно.

Сердце этого кода находится в строке 4 — здесь строится отношение наследования между bи a.

Давайте добавим пару console.log()операторов тут и там в этот фрагмент кода и таким образом проверим объект bболее точно:

var a = { x: 10, y: 20 };

// make a as the prototype
var b = Object.create(a);

console.log(b);

console.log('b.x:', b.x);
console.log('b.y:', b.y);

// add the properties one-by-one
b.p = 100;
b.q = 200;

console.log('b.p:', b.p);
console.log('b.q:', b.q);
{} bx: 10 by: 20 bp: 100 bq: 200
Первый лог сообщает нам, что Object.create(a)просто создается пустой объект (прототипом которого является a).

Второй и третий журналы проверяют значения свойств xи yна b. Эти свойства не существуют напрямую в b. Однако они существуют по прототипу b, т.е. по объекту a. Следовательно, они в конечном итоге bтакже доступны.

Последние два журнала просто проверяют значения свойств pи qon b, которые являются его собственными свойствами и просто разрешаются до 100и 200.

Как вы, возможно, уже заметили в приведенном выше коде, использование Object.create()не позволяет удобно инициализировать создаваемый объект с заданным набором свойств. То есть мы должны вручную добавлять каждое свойство одно за другим после создания объекта.

Хотя это еще не большая проблема, в конечном итоге возникает неудобство, если все, что нам нужно сделать, это быстро инициализировать только что созданный объект буквальным обозначением.

Однако, как мы увидим позже, это неудобство становится почти незначительным, когда мы определяем методы для только что созданного объекта, поскольку методы должны содержать функциональное выражение и обычно не определяются в одном потоке (т. е. они обычно имеют тела охватывающих несколько строк) по сравнению с другими значениями, которые могут быть определены в потоке.

Object.create()также может быть вызван nullв качестве аргумента.

В этом случае создается (и возвращается) новый объект, прототипом которого является null. То есть этот объект не наследует никаких свойств, так как у него нет прототипа.

Рассмотрим следующий код:

// create an object with a null prototype
var o = Object.create(null);

o.x = 10;
o.y = 20;

console.log(o);
{x: 10, y: 20}
Здесь мы создаем объект Object.create(null), используя прототип, nullа затем присваиваем его переменной o. Затем мы добавляем два свойства xи yк этому объекту, а затем регистрируем его.

Помните, что oэто все еще объект и, следовательно, может иметь свойства. Просто это [[Prototype]]так null.

Цепи прототипов
Давайте оценим тот факт, что прототип любого данного объекта также является объектом в конце концов. Точно так же, как мы уже говорили ранее, каждый отдельный объект в JavaScript имеет соответствующий прототип, это означает, что объект-прототип также будет иметь прототип.

Не так ли?

Это подводит нас к определению другого термина — цепочки прототипов :

Для данного объекта oего цепочка прототипов представляет собой просто список прототипов , первый элемент которого является прототипом o, любой последующий элемент является прототипом предыдущего элемента, а последний элемент просто null.
Цепочка прототипов — это просто список, который определяет прототип объекта, затем прототип этого прототипа, затем прототип прототипа этого прототипа и так далее.

Это вполне естественная концепция, заметная в некоторых сценариях реальной жизни. Например, мы наследуем генетику от наших родителей, а наши родители наследуют генетику от своих родителей, и так далее и тому подобное.

Рассмотрим пример.

В приведенном ниже коде мы определяем объект a, затем объект bс прототипом aи, наконец, объект cс прототипом b:

var a = { x: 10, y: 20 };
var b = Object.create(a);
var c = Object.create(b)
Имея этот код, мы напишем цепочку прототипов cследующим образом:

b → a

Это означает, что cон наследует данные, от bкоторых, в свою очередь, наследует данные от a. Обратите внимание, как стрелка начинается bи указывает на a . Это как раз следует из того, что bсодержит [[Prototype]]внутренний атрибут, указывающий на a.

Но подождите... Цепочка кажется незавершенной. Мы не указали прототип aв цепочке.

Что ж, вы абсолютно правы!

Как мы уже говорили ранее, когда мы создаем объект, используя синтаксис литерала объекта, его прототипу автоматически присваивается значение Object.prototype. Следовательно, в нашем случае aнаследуется от Object.prototype, который в свою очередь имеет nullпрототип.

Таким образом, полная цепочка прототипов cбудет выглядеть так:

b → a → Object.prototype → null

Идея цепочек прототипов в JavaScript имеет практическое значение для языка при разрешении свойств объектов.

Посмотрим, что это значит...

Механизм поиска собственности
Когда мы извлекаем свойство объекта в JavaScript, фактически в фоновом режиме выполняется целый ряд шагов для разрешения свойства.

Давайте посмотрим пример.

Предположим, у нас есть три объекта o1, o2как o3показано ниже:

var o1 = { a: 100, b: 200, c: 300 };
var o2 = { a: 10, b: 20 };
var o3 = { a: 1 };
Также предположим, что o3наследуется от o2и o2наследуется от o1. Описывая это визуально, более поздние объекты в коде наследуются от ранее определенных объектов.

Теперь давайте посмотрим, во что превратится пара выражений доступа к свойствам при o3разрешении:

o3.aвозвращается 1; o3.bвозвращается 20; o3.cвозвращается 300; o3.nonExistentвозвращается undefined.

Давайте посмотрим то же самое для объекта o2:

o2.aвозвращается 10; o2.bвозвращается 20; o2.cвозвращается 300; o2.nonExistentвозвращаетсяundefined
И теперь, наконец, для объекта o1:

o1.aвозвращается 100; o1.bвозвращается 200; o1.cвозвращается 300; o1.nonExistentвозвращается undefined;

Вы заметили какую-то закономерность?

Всякий раз, когда осуществляется доступ к свойству данного объекта в JavaScript, если это свойство существует в объекте, то оно используется для разрешения выражения доступа к свойству.

В противном случае свойство ищется на прототипе. Если оно существует, исходное выражение доступа к свойству объекта разрешается с этим значением. В противном случае поиск переходит к следующему прототипу по цепочке, затем к следующему и так далее.

Этот поиск останавливается, когда свойство в конечном итоге найдено в прототипе или когда nullпрототип достигается при обходе цепочки прототипов. Когда nullпрототип достигнут, это означает, что свойство нигде не было найдено, и также undefinedвозвращается.

Это алгоритм разрешения свойства (в общем виде), используемый JavaScript, когда мы обращаемся к свойству данного объекта.

Один из самых больших выводов из этого механизма разрешения свойств заключается в том, что свойства, определенные в объекте, затеняют свойства, доступные в его прототипе. Формально это называется слежкой за собственностью .

Например, в приведенном выше коде свойство aзатеняет o3свойство aв o2выражении o3.a. Точно так же свойство bтени o2свойство bв o1выражении o2.b.

В любом случае, с практической точки зрения, эта модель позволяет JavaScript эмулировать отношения класс-подкласс-подкласс из классических языков ООП и даже с большей гибкостью, чем в этих языках.

Понятие извлечения свойств интуитивно понятно и легко для понимания, как вы только что видели выше. Однако назначение свойств в JavaScript во многих аспектах не так очевидно и интуитивно понятно.

Механизм присвоения свойств
Как разработчику, нам важно знать о некоторых очень неожиданных случаях при назначении свойств объектам, чтобы наши приложения не вызывали каких-либо ошибок или странного поведения.

Давайте посмотрим, как присваивание свойств работает в JavaScript.

Скажем, у нас есть объект oс собственным свойством prop. Если свойство является недоступным для записи свойством данных или свойством доступа без установки самого объекта o(является oсобственным свойством ), что, по вашему мнению, произойдет с выражением присваивания свойства, показанным ниже?

o.prop = value;
Ну а если скрипт работает в строгом режиме, то получим ошибку. В противном случае присвоение свойства будет молча игнорироваться.

Довольно простой.

Что удивительно в JavaScript, так это то, что это понятие распространяется на цепочку прототипов объекта o; не только на самом объекте.

То есть, если свойство не существует в самом объекте, но существует в каком-то объекте в его цепочке прототипов, тогда применяется то же правило, что показано выше. Другими словами, если свойство propявляется унаследованным свойством данных, недоступным для записи, или унаследованным свойством доступа без установщика, недопустимо присваивать значение этому свойству на o.

Давайте на деле продемонстрируем это.

Сначала мы рассмотрим простейший случай — когда свойство является собственным свойством данных объекта или собственным свойством-аксессором:

var o = {};

// non-writable data property
Object.defineProperty(o, 'x', { value: 'old' });

// setter-less accessor property
Object.defineProperty(o, 'y', {
get: function() { return 'old'; }
});

o.x = 'new';
console.log('o.x:', o.x);

o.y = 'new';
console.log('o.y:', o.y);
ox: старый oy: старый
Как вы видите, оба выражения присваивания свойств в строках 11 и 14 не действуют. Если бы этот скрипт работал в строгом режиме, мы получили бы ошибку в самом первом выражении присваивания свойств в строке 11.

Теперь давайте рассмотрим случай, когда свойство не является собственным свойством объекта, а является унаследованным свойством:

var o = {};

// non-writable data property
Object.defineProperty(o, 'x', { value: 'old' });

// setter-less accessor property
Object.defineProperty(o, 'y', {
get: function() { return 'old'; }
});

var a = Object.create(o);

a.x = 'new';
console.log('a.x:', a.x);

a.y = 'new';
console.log('a.y:', a.y);

console.log(a);
Здесь все то же, что и раньше, за исключением того, что теперь выражения присваивания свойств (в строках 13 и 16) работают с объектом a, а не с o. aПрототип объекта o.

Теперь самое удивительное — это вывод этого кода:

топор: старый ау: старый {}
Как мы знаем из приведенного выше кода, у объекта нет таких свойств, как xи , поэтому мы можем ожидать, что выражения и создадут эти свойства у объекта .yaa.x = 'new'a.y = 'new'a

Это НЕ так.

Вместо этого выражения присваивания свойств также включают поиск ключа свойства в объекте и, если он не найден, то в цепочке прототипов этого объекта.

Это объясняет, почему a.x = 'new'вообще не действует (или выдает ошибку, если наш скрипт был в строгом режиме). Свойство xнаходится в прототипе a, то есть в объекте o, где оно настроено как недоступное для записи. Точно так же JavaScript запрещает присваивать значение свойству даже в производном объекте a.

Аналогичное рассуждение применимо и к a.y = 'new'. Свойство yищется в a, а затем в его прототипе, то есть в объекте o, где оно оказывается свойством-аксессором без функции установки. Следовательно, JavaScript просто игнорирует оператор a.y = 'new'(или выдает ошибку в строгом режиме), как это было бы, если бы yбыло aсобственное свойство доступа без установки.

Обратите внимание, что если бы унаследованное yздесь свойство доступа (определенное в объекте o) имело функцию установки, совершенно очевидно, что она была бы вызвана при выполнении a.y = 'new'.

Это можно увидеть следующим образом:

var o = {};

// non-writable data property
Object.defineProperty(o, 'x', { value: 'old' });

// setter-less accessor property
Object.defineProperty(o, 'y', {
get: function() { return 'old'; },
set: function(value) {
console.log('Setter called with value:', value);
}
});

var a = Object.create(o);

a.x = 'new';
console.log('a.x:', a.x);

a.y = 'new';
console.log('a.y:', a.y);

console.log(a);
ax: старый Setter вызывается со значением: new ay: old {}
Ясно, что установщик унаследованного свойства вызывается оператором a.y = 'new', как видно из второго журнала.

В обоих этих фрагментах кода также обратите внимание на последний журнал, {}т.е. Он эффективно показывает объект aпосле выполнения операторов присваивания свойств. Он пуст, что ясно указывает на то, что выражения присваивания свойств не создают соответствующие свойства в a.

В реальных приложениях эта идея используется довольно широко — даже в некоторых предопределенных API, предоставляемых JavaScript.

Идея недоступных для записи свойств данных в прототипе, предотвращающая присвоение свойства с идентичным именем любому из производных объектов, используется нечасто. Причина этого очень ясна, и мы неоднократно заявляли об этом в этой и предыдущей главах.

Свойства данных, которые непосредственно содержат заданные данные, предназначены только для обозначения признаков объекта и, следовательно, предназначены для определения непосредственно в экземплярах, а НЕ в их прототипах.

В отличие от этого, когда мы рассматриваем поведение экземпляров (т. е. некоторых функций), они обычно определяются на прототипе этих экземпляров.

И, как мы знаем, свойства доступа — это просто украшение по сравнению с использованием двух разных методов для выполнения задачи над объектом. Например, вместо того, чтобы определять метод getX()и для объекта, мы могли бы просто определить свойство доступа с заданными функциями получения и установки, чтобы позаботиться о извлечении и назначении этого свойства соответственно.setX()Pointx

Фактически это означает, что мы можем определить свойства доступа к прототипу экземпляра и, таким образом, получить его функциональные возможности, которые будут использоваться всеми экземплярами.

Имейте в виду, что та же функция может быть достигнута с помощью методов экземпляра, определенных в классе — свойство свойства доступа просто предоставляет более удобный интерфейс для получения и установки значения, что действительно имеет смысл, когда имя свойства — существительное.

Напомним, что присвоение свойства объекту не будет иметь никакого эффекта (в нестрогом режиме) или вызовет ошибку (в строгом режиме), если свойство является недоступным для записи собственным/унаследованным свойством данных или собственным/без установщика. унаследованное имущество.

Если это не так, то, если свойство является собственным/унаследованным свойством доступа с функцией установки, то назначение свойства вызовет эту функцию установки с назначенным значением.

А если это не так, то собственное свойство данных просто создается или обновляется в зависимости от того, существовало ли это свойство ранее.

Краткое резюме
Для данного объекта obj, данного свойства propи данного выражения JavaScript value, как разрешить выражение присвоения свойства, показанное ниже:

obj.prop = value

Ну, мы узнали именно это в обсуждении выше — есть несколько случаев, которые движок должен рассмотреть, прежде чем полностью выполнить оператор присваивания.

В приведенной ниже таблице хорошо представлена ​​вся эта информация.

Собственное или наследственное? Данные или свойство доступа? Доступен для записи? Есть сеттер? Результат
Своя Данные Да — Установите objсобственное свойство propв value.
Своя Данные Нет — Игнорировать назначение свойства (в нестрогом режиме) или выдавать ошибку (в строгом режиме).
Своя Аксессор — Да Вызвать функцию установки objсобственного свойства propс valueаргументом as.
Своя Аксессор — Нет Игнорировать назначение свойства (в нестрогом режиме) или выдавать ошибку (в строгом режиме).
Унаследовано Данные Да — Создайте objсобственное свойство propи установите для него значение value.
Унаследовано Данные Нет — Игнорировать назначение свойства (в нестрогом режиме) или выдавать ошибку (в строгом режиме).
Унаследовано Аксессор — Да Вызвать функцию установки objунаследованного свойства prop(очевидно, определенную для некоторого объекта в objцепочке прототипов) с valueаргументом as.
Унаследовано Аксессор — Нет Игнорировать назначение свойства (в нестрогом режиме) или выдавать ошибку (в строгом режиме).
Нет, т.е. не существует — — Нет Создайте objсобственное свойство данных propи установите для него значение value.

Собственные и унаследованные свойства
Объект в JavaScript наследует свойства от своего прототипа, который, в свою очередь, наследует свойства от своего прототипа, тот наследует свойства от своего прототипа, который снова наследует свойства от своего прототипа, и так далее и тому подобное.

Если данное свойство существует непосредственно в объекте, оно имеет приоритет над тем же свойством где-то в цепочке прототипов объекта при доступе к объекту.

Например, если objis {x: 0}и protois {x: 10, y: 10}, где protoявляется прототипом obj, то obj.xбудет возвращено, 0поскольку xсуществует само по себе и, таким образом , objимеет приоритет над свойством x.proto

Напомним, что это явление известно как свойство затенения, т.е. свойство xтени objсвойство xв protoвыражении obj.x.

Теперь для данного объекта важно это различие между теми свойствами, которые определены непосредственно в объекте, и теми, которые определены где-то в его цепочке прототипов.

В JavaScript нам дается несколько утилит, позволяющих установить это различие для данного свойства на самом деле в коде.

Но сначала давайте поговорим о различии более точно.

Свойство, доступное для объекта, может быть его собственным свойством или унаследованным свойством .

Для данного объекта любое свойство, определенное непосредственно в объекте, называется его собственным свойством .
Например, в приведенном выше примере, если objis {x: 0}, то xis является objсобственным свойством.

Сходным образом,

Для данного объекта любое свойство, определенное где-то в его цепочке прототипов, но не в самом объекте, называется его унаследованным свойством .
Унаследованные свойства иногда также называют общими свойствами . Этот термин происходит от того факта, что эти свойства являются общими для объектов, унаследованных от прототипа, на котором эти свойства определены.

Как мы видели ранее, необязательно, чтобы унаследованное свойство объекта исходило непосредственно от его прототипа — свойство может исходить от самого последнего объекта в цепочке прототипов.

Если свойство в конечном итоге доступно для объекта (благодаря самому объекту или цепочке его прототипов) и если это свойство не является собственным свойством объекта, то точно известно, что это унаследованное свойство.

Обратите внимание, что если свойство не является собственным свойством объекта, то оно не обязательно должно быть унаследованным свойством — оно может просто не существовать в объекте или цепочке его прототипов.

Метод объектов помогает нам определить hasOwnProperty(), является ли данное свойство собственным свойством объекта.

obj.hasOwnProperty(propName)
Объект obj, свойство которого должно быть проверено, является вызывающей стороной метода, в то время как имя свойства передается методу в качестве аргумента.

Возвращаемое значение hasOwnProperty()является логическим значением, trueесли данное свойство является objсобственным свойством, иначе false.

Давайте попробуем этот метод:

В приведенном ниже коде мы определяем объект, aа затем проверяем его, используя его hasOwnProperty()метод:

var a = { x: 0, y: 0 };

console.log(a.hasOwnProperty('x'));
console.log(a.hasOwnProperty('y'));
console.log(a.hasOwnProperty('z'));
правда правда ложь
По-видимому, первый журнал trueпросто потому , что xон является aсобственностью . Так и имущество y. Тем не менее, zэто не aего собственная собственность, и мы также получаем falseв последнем журнале.

Давайте явно введем прототип в этот код, а затем проведем еще одну дополнительную hasOwnProperty()проверку:

var proto = { z: 0 };

var a = Object.create(proto);
a.x = 0;
a.y = 0;

console.log(a.hasOwnProperty('x'));
console.log(a.hasOwnProperty('y'));
console.log(a.hasOwnProperty('z'));

console.log(proto.hasOwnProperty('z'));
Обратите внимание, что объект aздесь имеет те же свойства, что и раньше — он определен иначе (т. е. не буквально) из-за того, что он создан с помощью Object.create().

Вывод этого кода выглядит следующим образом:

правда правда ложь правда
Первые три журнала такие же, как и раньше. Четвертый журнал определяет, является ли zэто protoсобственным свойством, и, поскольку это так, вывод журнала равен true.

Легкий?

Давайте проведем быстрый тест.

Учитывая приведенный ниже код, что будет o.hasOwnProperty('x')возвращено?

var o = {};

Object.defineProperty(o, 'x', {
value: 0
});
true
false

Прототипы и inоператор
Мы видели inоператор в главе « Основы объектов », в самом начале этого раздела. Он определяет, находится ли свойство в объекте или нет.

Ну, это мягко сказано.

Точнее говоря, inоператор, работающий с объектом и именем свойства, определяет, является ли свойство собственным или унаследованным свойством объекта. Другими словами, просто сообщает нам, доступноin ли данное свойство для объекта.

Это означает, что, начиная с самого объекта, он эффективно проходит всю цепочку прототипов этого объекта в поисках свойства, пока оно не будет найдено.

Рассмотрим следующий код:

var proto = { y: 0 }

var o = Object.create(proto);
o.x = 0;

console.log('x' in o);
console.log('y' in o);

console.log('hasOwnProperty' in o);

console.log('nonExistent' in o);
правда верно верно неверно
Первый журнал определяет, oдоступен ли объект o, и поскольку он есть, мы получаем trueвывод. Второй журнал определяет, yдоступен ли он на o, и еще раз, поскольку он есть, мы получаем другой trueвывод.

Третий журнал может быть нелогичным — мы не определили ни hasOwnPropertyon o, ни его прототип proto, но у нас есть доступ к нему, как определено inоператором.

Как мы скоро подробно увидим, это hasOwnPropertyсвойство исходит из того Object.prototype, что в данном случае является прототипом proto(и каждого объекта, созданного с помощью {}или new Object()).

Окончательный журнал выводит false, потому что данное свойство nonExistentне существует ни в o, ни в каком-либо объекте в его цепочке прототипов.

Простой.
Оператор inвместе с hasOwnProperty()можно использовать для определения того, является ли произвольное свойство данного объекта его собственным свойством, унаследованным свойством или просто несуществующим свойством.

Эта реализация этого оставлена ​​в качестве упражнения в следующей части этого модуля. Если вы хотите сделать это прямо сейчас, перейдите к Объекты — Упражнение по проверке свойств на следующей странице.

prototypeНедвижимость \_
Еще в прошлой главе мы показали шаги, предпринимаемые внутри движком JavaScript при вызове функции-конструктора, т. е. с помощью newключевого слова.

Давайте вспомним эти шаги:

Учитывая функцию F, выражение выполняет внутренний метод , который выполняет следующие шаги:new F()[[Construct]]F

Создается новый пустой объект.
Прототип этого объекта установлен в F.prototype. Мы поймем этот шаг намного лучше, когда узнаем о прототипах в следующей главе.
Внутренний [[Call]]метод функции выполняется с его thisустановкой на объект, созданный на шаге 1.
Объект, созданный на шаге 1, возвращается.
Шаг 1 довольно прост для понимания — он просто создает наиболее атомарный из типов данных JavaScript, т. е. объект. Шаг 2, однако, был расплывчатым, по крайней мере, до этой главы. Теперь мы разгадаем всю идею, стоящую за этим.

Когда данная функция Fвызывается как , то, как мы уже знаем, мы возвращаем новый объект — или, лучше сказать, экземпляр .new F()F()

Прототип этого экземпляра автоматически устанавливается в F.prototypeт. е. в prototypeсвойство F, в процессе создания экземпляра.

Так что же F.prototypeдля этой функции F?

Что ж, как может показаться на первый взгляд (как и я изначально, изучая JavaScript), F.prototypeкажется, что это приводит нас к прототипу F(помните, что Fэто объект-функция).

Это совершенно неправильно!

Термин «F.prototype» кажется сбивающим с толку и вводящим в заблуждение.

Чтобы упростить это, как правило, всегда помните, что в JavaScript нет стандартного способа получить прототип объекта через свойство этого объекта.

Существует нестандартное свойство с именем **proto**, но опять же, это не стандартный способ. Мы узнаем больше об **proto**этом позже в этой главе.
Это в основном устраняет мысль о F.prototypeтом, чтобы быть прототипом F. Большое нет.

Давайте теперь посмотрим, что F.prototypeесть.

F.prototypeэто просто удобный (и, честно говоря, умный) способ обозначить прототип любого экземпляра конструктораF() .
Простой!

FИбо сама функция F.prototypeесть не что иное (буквально не что иное), как свойство, значением которого является объект. С точки зрения самого себя в этом нет ничего особенного .F.prototypeF

Но с точки зрения экземпляра имеет особое значение F(). F.prototypeТо есть это прототип этого экземпляра (и всех других экземпляров F()).

Свойство prototypeобъектов функций — одна из самых полезных и мощных концепций JavaScript. Тонны и тонны утилит во всем языке определяются prototypeсвойствами заданных функций.

Свойство prototype— это то, что в конечном итоге будет использоваться для решения проблемы, с которой мы столкнулись в предыдущей главе, — определения метода внутри тела функции-конструктора.

Рассмотрим простой Point()конструктор ниже, без определения setTo()метода внутри него:

function Point(x = 0, y = 0) {
this.x = x;
this.y = y;
}
Хорошо, теперь давайте применим все наши знания о прототипах для определения setTo(). Но не так быстро — мы рекомендуем вам сначала подумать над решением.

Где определить setTo()метод?
Из всех обсуждений, которые мы провели до сих пор, мы знаем, что это Point.prototypeуказывает на объект, который является прототипом каждого Pointэкземпляра. То есть Pointэкземпляр наследует свойства от Point.prototype.

Таким образом, если мы определим setTo()метод на объекте Point.prototype, то каждый Pointэкземпляр будет иметь к нему доступ. Другими словами, мы могли бы сделать что-то вроде p1.setTo()того, если предположим, что p1это Pointэкземпляр.

Вуаля!

Мы решили нашу проблему определения метода.

Ниже показан полный код:

function Point(x = 0, y = 0) {
this.x = x;
this.y = y;
}

Point.prototype.setTo = function(x, y) {
this.x = x;
this.y = y;
}
Метод setTo()определен на Point.prototypeобъекте. В результате он доступен для всех Point экземпляров.

Ниже мы тестируем setTo()метод на экземпляре p1:

var p1 = new Point();
неопределенный
p1.x
0
p1.y
0
p1.setTo(5, 15)
неопределенный
p1.x
5
p1.y
15
Да, это работает!

Давайте посмотрим на преимущества использования Point.prototypeдля определения setTo():

Мы не создаем новую setTo()функцию для каждого нового Pointэкземпляра. Функция определяется один раз и сохраняется в файле Point.prototype.
Мы не создаем новое setTo()свойство для каждого Pointэкземпляра. Свойство определяется ровно один раз для объекта Point.prototypeи оттуда в конечном итоге находит свой путь в разрешении setToкак доступ к любому Pointэкземпляру.
Мы никоим образом не заполняем глобальную область видимости — вся Pointфункциональность, связанная с , находится внутри Pointфункционального объекта.
В целом это означает, что использование прототипа для определения методов экземпляра намного эффективнее с точки зрения памяти, чем использование тела конструктора, а также намного лучше с точки зрения удобочитаемости и удобства сопровождения. Например, в случае каких-либо ошибок или странного поведения с Pointэкземпляром мы знаем, что должны искать в Pointобъекте функции (либо в его теле, либо в Point.prototype).

Удивительно!

Давайте посмотрим на другой пример, на этот раз связанный со свойством доступа к прототипу.

Предположим, у нас есть приложение интернет-магазина продуктов, в котором каждый товар представлен классом item. Для ясности мы абстрагируем любые детали более низкого уровня, хранящиеся для каждого элемента, такие как идентификатор или его категория (например, фрукты, овощи, молочные продукты и т. д.).

У каждого товара есть два свойства данных: actualPriceэто дает фактическую цену товара (до любых скидок) и sellingPriceего текущую продажную цену, и, наконец, свойство доступа discount, которое дает значение скидки для товара в процентах.

Смысл предоставления discountв качестве свойства средства доступа, а не свойства данных, заключается в том, чтобы не допустить избыточного сохранения данных в памяти. Если мы знаем фактическую цену товара и его текущую продажную цену, мы можем легко рассчитать скидку по этим двум значениям — нет смысла сохранять ее отдельно.

Кроме того, смысл предоставления discountв качестве свойства доступа, а не в виде двух отдельных методов (скажем, getDiscount()и setDiscount()) состоит в том, чтобы сохранить простой интерфейс. Слово «скидка» — это существительное, а существительные хорошо подходят как свойства класса в ООП, а не как методы.

Глаголы хорошо подходят в качестве методов в ООП.
Время реализовать Itemкласс:

function Item(sellingPrice, actualPrice) {
this.sellingPrice = sellingPrice;
this.actualPrice = actualPrice;

    Object.defineProperty(this, 'discount', {
        get: function() {
            return (this.actualPrice - this.sellingPrice)
                     / this.actualPrice * 100;
        },
        set: function(perc) {
            this.sellingPrice = this.actualPrice
                                      - perc / 100 * this.actualPrice;
        },
        configurable: true,
        enumerable: true
    })

}
Теперь давайте создадим Itemэкземпляр с предполагаемыми actualPriceи sellingPriceзначениями, а затем получим его скидку:

var item = new Item(25, 50)
неопределенный
item.sellingPrice
25
item.actualPrice
50
item.discount
50
Получение на самом деле совсем не удивительно, как мы обсуждали ранее.

Настоящий сюрприз и сила заключается в установке значений для унаследованных свойств доступа.

В приведенном ниже коде мы стремимся установить 30в качестве скидки Itemэкземпляра item.

Как указывалось ранее, настоящим сюрпризом здесь является то, что выражение item.discount = 30не создает новое собственное свойство discount, itemа скорее делегирует присвоение свойства прототипу, itemт. е. объекту Item.prototype, где в конечном итоге это приводит к вызову метода установки свойства средства доступа discount.

Большой!

В этом сила модели прототипа, используемой в JavaScript. Объекты наследуют данные напрямую от других объектов. Как просто, но как сильна идея. Ух ты!

То, что мы только что показали, является лишь началом потенциала этого прототипа. Все станет интереснее и сложнее, когда мы расширим наши знания до прототипного наследования .

Но перед этим давайте обсудим ключевой метод, используемый в прототипном наследовании — Object.create().

Прототипное наследование
В мире ООП класс может быть основан на другом классе и, таким образом, наследовать от него что-то. Например, кошки — это животные, и поэтому мы можем сказать, что Catкласс основан на классе Animal.

Прелесть ООП в том, что можно построить это наследство сколь угодно глубоко и, таким образом, красиво смоделировать множество объектов (и их взаимосвязей) в реальной жизни и, что наиболее важно, в воображаемой компьютерной жизни.

Например, как мы видели в предыдущей главе, программное обеспечение для рисования графики может иметь класс Itemдля представления элементов на холсте приложения, класс, Shapeоснованный на Itemспециальном представлении фигур, таких как прямоугольники, круги, многоугольники и т. д., и, возможно, даже класс, Squareоснованный на для Rectangleпредставления квадратов.

В разделе выше мы увидели, как определить конструктор, а затем настроить prototypeсвойство этого конструктора для хранения всех его методов экземпляра.

Таким образом, мы сказали, что функция-конструктор в JavaScript действует почти так же, как класс из традиционного языка ООП.

Но, как мы уже знаем, классы в классических языках ООП могут наследоваться от заданных классов. Например, если в классе Catесть вызываемый метод, meow()а в Animalклассе есть вызываемый метод walk(), то Catэкземпляр может выполнять и то, meow()и другое walk(). Другими словами, a Catбудет иметь все поведение Animal.

Вопрос в том, можем ли мы сделать это в JavaScript? Можем ли мы использовать его механизм прототипа для эмуляции наследования класса-подкласса?

Что ж, еще раз, мы сначала позволим вам подумать об этом...

Итак, что вы думаете. Да или нет? Может ли прототип модели JavaScript эмулировать наследование класса-подкласса?

Мы уже видели, что он может полностью эмулировать класс.

Что ж, чтобы покончить с ожиданием, да, мы могли бы сделать это на JavaScript.

На самом деле предопределенные API-интерфейсы JavaScript построены на идее наследования классов от классов. Класс Numberнаследуется от Object, как и String, Boolean, Array— все они основаны на Objectклассе.

Давайте посмотрим, как именно мы можем это сделать на конкретном примере.

В предыдущей главе мы придумали воображаемое приложение для рисования, в котором люди могли бы рисовать простые фигуры, раскрашивать их, добавлять текст и т. д.; очень похоже на облегченную версию полноценного программного обеспечения для редактирования графики.

Мы разработали два специальных класса в приложении, т . е. Rectдля обозначения прямоугольников и Shapeдля обозначения фигур. Мы сказали, что, поскольку прямоугольники являются фигурами, они Rectнаследуются от Shape.

Вплоть до предыдущей главы мы могли моделировать только состояние этих классов, т. е. свойства экземпляров, так как мы не были знакомы с прототипами. Теперь мы определим некоторые гипотетические методы для них обоих и определим отношения наследования между классами.

Итак, во-первых, давайте придумаем пару методов для Rectи Shape.

Если бы это было реальное приложение, мы должны были бы иметь возможность перемещать заданную фигуру в любое место на холсте (или просто на экране), перетаскивая, а затем перемещая элемент с помощью указателя мыши. Это намекает нам, что это move()может быть метод экземпляра класса Shape.

Определим другой метод. Можно удалить фигуру, нажав Delкнопку, когда эта фигура выбрана. Это намекает нам, что delete()может быть другой Shapeметод.

А пока давайте просто определим эти методы гипотетически. Мы до сих пор не знаем, как на самом деле будет построена фигура в приложении. Так что в конце концов мы не могли реально реализовать каждый из этих методов move()и delete(). Мы просто будем использовать простые console.log()операторы, выводящие, что данная функциональность реализуется.

Вот и все!

В приведенном ниже коде мы расширяем Shape()конструктор, определенный в предыдущей главе, дополняя его prototype:

function Shape(x, y, fill = '#000') {
this.x = x;
this.y = y;
this.fill = fill;
}

Shape.prototype.move = function(x, y) {
console.log('Moving the shape to (${x}, ${x}).');
}

Shape.prototype.delete = function(x, y) {
console.log('Deleting the shape.');
}
Определившись Shapeполностью, пришло время рассмотреть Rectкласс. Класс Rectможет определить draw()метод для рисования прямоугольника на холсте. Расширение Rectконструктора из предыдущей главы, вот как Rect()будет выглядеть, включая Rect.prototype.

function Rect(width, height, x, y, fill) {
// initialise this Shape
Shape.call(this, x, y, fill);

    this.width = width;
    this.height = height;

}

Rect.prototype.draw = function() {
console.log('Drawing the rectangle.');
}
Вспомните цель утверждения Shape.call(this, x, y, fill)здесь, в строке 3.

Он фактически получает Rectэкземпляр со всеми чертами Shapeэкземпляра, вызывая Shape()конструктор с соответствующими аргументами. Это снижает необходимость повторения кода Shape()внутри Rect()— мы просто повторно используем Shape()конструктор.

Часть наследования выполнена, т.е. свойства (характеристики) инициализированы — теперь нам осталась только часть наследования методов от Shapeкласса.

Как это сделать?

Что ж, если бы мы могли каким-то образом настроить прототип Rect.prototypeдля наследования Shape.prototype, тогда мы были бы на правильном пути. Теперь, как это сделать?

Хм. Хороший вопрос. Давайте подумаем над этим...

Один из способов — это умный обходной путь. Сначала мы устанавливаем Rect.prototype, new Shape()а затем определяем все методы экземпляра Recton Rect.prototype. Это имеет очень очевидное последствие: Rect.prototypeего прототип настраивается на Shape.prototype.

В приведенном ниже коде мы определяем Rect()функцию, как и раньше, а затем устанавливаем Rect.prototypeзначение new Shape()в строке 9, прежде чем определять для draw()нее метод:

/_ ... Shape definition _/

function Rect(width, height, x, y, fill) {
// initialise this Shape
Shape.call(this, x, y, fill);

    this.width = width;
    this.height = height;

}

Rect.prototype = new Shape();

Rect.prototype.draw = function() {
console.log('Drawing the rectangle.');
}
Имейте в виду, что Shapeэкземпляр, назначенный Rect.prototypeздесь, предназначен только для расширения цепочки прототипов Rectэкземпляра, чтобы включить Shape.prototypeобъект после Rect.prototypeобъекта.

Он не предназначен для использования в качестве экземпляра — это объясняет, почему мы не передаем аргументы в new Shape().

Вот именно!

Теперь, как это ясно кажется, довольно расплывчато вызывать new Shape()и назначать его Rect.prototype. По крайней мере, в этом случае можно было передать аргументы конструктору Shape(), но если бы это было невозможно, нам пришлось бы вручную передавать заданные аргументы.

Откровенно говоря, расширять цепочку прототипов экземпляра таким образом — свободная практика. В идеале вызовы конструктора должны использоваться только для создания фактических экземпляров, а не для создания некоторых фиктивных экземпляров с целью назначения F.prototypeдля данной функции F.

Даже с программной точки зрения вызов new Shape()создает Rect.prototypeизбыточные свойства x, yкоторые никогда не будут использоваться fill.Rect.prototype

Гораздо лучший способ, как с технической точки зрения, так и с точки зрения удобочитаемости кода, — использовать этот Object.create()метод.

Давайте настроим прототип Rect.prototypeбез использования new Shape().

Способ сделать это... Вы должны сначала подумать об этом. Это очень просто, поверьте.

Итак, предположив, что вы хорошо поработали, давайте посмотрим, Object.create()как реализовать наследование самого прототипа.

Напомним, что Object.create()создается новый объект, для прототипа которого задан первый аргумент, переданный методу. В нашем случае нам нужно установить прототип объекта Rect.prototypeв Shape.prototype.

Итак, что нам нужно сделать, это просто Object.create()передать его Shape.prototypeв качестве аргумента, а затем присвоить полученный объект Rect.prototype.

Вуаля!

Это будет иметь два последствия:

Rect.prototypeбудет пустым объектом, так как мы не передали никаких свойств инициализации через второй аргумент в Object.create().
Во- вторых, Shape.prototypeбы стал прототипом Rect.prototype. То есть все, что определено Shape.prototype, будет доступно во всех экземплярах Rect.prototypeи, в конечном счете, во всех Rectэкземплярах.
Идеально!

В приведенном ниже коде мы реализуем этот простой Object.create()трюк, а затем переходим к нашим обычным Rectопределениям методов экземпляра.

/_ ... Shape definition _/

function Rect(width, height, x, y, fill) {
// initialise this Shape
Shape.call(this, x, y, fill);

    this.width = width;
    this.height = height;

}

Rect.prototype = Object.create(Shape.prototype);

Rect.prototype.draw = function() {
console.log('Drawing the rectangle.');
}
Теперь давайте протестируем все, как раньше:

var r1 = new Rect(20, 50, 0, 0);
неопределенный
r1.draw()
Рисование прямоугольника.
неопределенный
r1.move(-1, 5)
Перемещение формы в (-1, 5).
неопределенный
r1.удалить()
Удаление формы.
неопределенный
Большой! Код работает так, как ожидалось.

Более того, самое приятное то, что теперь нет лишних свойств, Rect.prototypeкак было раньше (при использовании new Shape()).

Object.create()— одна из прелестей JavaScript. Что еще более прекрасно, так это то, что его можно реализовать исключительно на идее конструктора и его prototypeсвойства. Подробнее об этом позже в следующем упражнении в этом разделе.

Какова цепочка прототипов r1объекта выше.

Rect.prototype, Shape.prototype
Rect.prototype, Shape.prototype, Object.prototype
Rect, Rect.prototype, Shape.prototype
Rect, Rect.prototype, Shape.prototype, Object.prototype

Получение прототипа
До сих пор мы видели множество концепций, вращающихся вокруг довольно простой идеи прототипов. Мы видели, как создать объект с заданным прототипом; как определить материал в prototypeсвойстве конструктора, который в конечном итоге будет повторно использоваться всеми его экземплярами; и, наконец, как реализовать прототипное наследование.

Тем не менее, по-прежнему остается без ответа очень важный вопрос.

То есть, имея любой объект, как мы можем получить его прототип?

Что ж, если объект является экземпляром конструктора F, то прототип этого объекта просто равен F.prototype.

Но если мы вообще не знаем о конструкторе объекта, это будет проблемой. Что ж, получить конструктор экземпляра довольно просто — просто используйте constructorсвойство.

Но что, если constructorсвойство недоступно для экземпляра?

В этом случае, очевидно, мы не сможем получить конструктор этого объекта и, следовательно, его prototypeсвойство.

Даже если все сделано правильно, может случиться так, что прототип объекта отличается от prototypeсвойства его конструктора. Посмотрим, как это возможно.

Более того, в некоторых случаях получить прототип объекта вручную может быть совершенно невозможно.

Чтобы свести к минимуму это долгое обсуждение, можно сказать, что ручное определение прототипа объекта вообще ненадежно — оно может дать неожиданные результаты, а в некоторых случаях вообще не дать никакого результата!

Получается, что давным-давно разработчики движка JavaScript осознали, что получение прототипа данного объекта — не такое уж редкое желание в приложении, и поэтому придумали нестандартный способ получения прототипа объекта. — **proto**имущество .

Для данного объекта oего **proto**свойство просто возвращает ссылку на прототип o.
Свойство **proto**является свойством доступа, определенным в Object.prototype. Таким образом, он доступен почти для всех объектов в JavaScript.
Давайте проверим **proto**пару объектов в JavaScript.

Для ясности мы не записывали **proto**объекты с заданными значениями ниже напрямую — мы сравнивали их с заданным объектом-прототипом, чтобы продемонстрировать возвращаемое значение **proto**в каждом случае.

[1, 2, 3].**proto** === Array.prototype
истинный
{ x: 0 }.**proto** === Object.prototype
истинный
10 .**proto** === Number.prototype
истинный
'10'.**proto** === String.prototype
истинный
var a = {}
неопределенный
Object.create(a).**proto** === a
истинный
function F() {}
неопределенный
F.**proto** === F.prototype
ЛОЖЬ
Последний журнал здесь особенно важно знать. Для данной функции ее **proto**свойство и prototypeсвойство не содержат одни и те же объекты.

Для функции Fсодержит F.**proto**прототип функционального объекта F, которым оказывается Function.prototype, тогда как F.prototypeсодержит прототип всех экземпляров F().

Теперь, из-за широкого внедрения этого нестандартного **proto**свойства, оно вскоре нашло свое отражение в стандарте ECMAScript, однако исключительно как устаревшая функция, предназначенная для обратной совместимости.

Вместо **proto**, была разработана более чистая и сложная утилита: статический Object.getPrototypeOf()метод.

Как подсказывает название,

Для данного объекта просто oвозвращает ссылку на прототип .Object.getPrototypeOf(o)o
Вот его синтаксис:

Object.getPrototypeOf(obj)
Единственный objаргумент указывает объект, чей прототип должен быть получен. Метод возвращает прототип obj.

Как и в случае с **proto**, давайте проверим этот метод на наборе значений:

Object.getPrototypeOf([1, 2, 3]) === Array.prototype
истинный
Object.getPrototypeOf({ x: 0 }) === Object.prototype
истинный
Object.getPrototypeOf(10) === Number.prototype
истинный
Object.getPrototypeOf('10') === String.prototype
истинный
var a = {}
неопределенный
Object.getPrototypeOf(Object.create(a)) === a
истинный
function F() {}
неопределенный
Object.getPrototypeOf(F) === F.prototype
ЛОЖЬ
Если вы разрабатываете приложения JavaScript и когда-нибудь захотите получить прототип данного объекта, вы ДОЛЖНЫ использовать этот стандартный Object.getPrototypeOf()метод.

Хотя **proto**поддерживается в основных браузерах, всегда рекомендуется избегать использования нестандартных функций, насколько это возможно, даже если между стандартными и нестандартными функциями практически нет разницы, как в случае с **proto**и Object.getPrototypeOf().

Подробнее об этом можно прочитать **proto**в официальной документации MDN для**proto** .

Установка прототипа объекта
Как мы видели выше, довольно просто запустить новый объект в JavaScript, который имеет заданный прототип.

Например, в случае функции-конструктора мы могли бы создать из нее экземпляр объекта, установить prototypeдля конструктора объект pи, таким образом, получить все экземпляры конструктора для наследования от p.

С другой стороны, Object.create()может использоваться для создания нового объекта с заданным прототипом, т. е. путем вызова , без необходимости вручную проходить процесс создания функции-конструктора, а затем инстанцирования.Object.create(p)

Все хорошо.

Но что, если у нас есть существующий объект и мы хотим изменить его прототип на какой-то другой объект.

До сих пор мы не видели никакого способа сделать это.

Однако есть способ. На самом деле, есть два способа сделать это:

Присвойте значение **proto**свойству объекта.
Вызов Object.setPrototypeOf()метода.
Присвоение значения **proto**свойству — это то же самое, как мы присваиваем значение любому другому свойству в JavaScript, т.е.obj.**proto** = value

С другой стороны, статический метод Object.setPrototypeOf()принимает два аргумента и делает второй прототипом первого.

Синтаксически это выглядит так:

Object.setPrototypeOf(obj, proto)
protoделается прототип объекта obj. Возвращаемое значение этого метода равно obj.

Простой!

Давайте посмотрим на обе эти утилиты в действии:

Вот наш старый пример с двумя объектами aи b:

var a = { x: 10, y: 20 };
var b = { p: 100, q: 200 };
Сделаем aпрототип b:

Во-первых, давайте сделаем это, используя **proto**:

var a = { x: 10, y: 20 };
var b = { p: 100, q: 200 };

b.**proto** = a;

console.log('b.x:', b.x);
console.log('b.y:', b.y);

console.log('b.p:', b.p);
console.log('b.q:', b.q);
bx: 10 by: 20 bp: 100 bq: 200
Теперь, используя Object.setPrototypeOf()метод:

var a = { x: 10, y: 20 };
var b = { p: 100, q: 200 };

Object.setPrototypeOf(b, a);

console.log('b.x:', b.x);
console.log('b.y:', b.y);

console.log('b.p:', b.p);
console.log('b.q:', b.q);
bx: 10 by: 20 bp: 100 bq: 200
Легко, не так ли?

Теперь вы можете подумать, что Object.setPrototypeOf()это намного лучше, чем использование Object.create(), потому что оно позволяет нам настроить прототип существующего объекта и, таким образом, избежать необходимости писать каждое из свойств одно за другим.

Это явно так кажется.

Проблема в том, что язык не поощряет это делать.

Если вы перейдете к официальной документации MDN поObject.setPrototypeOf() , или даже к документации по**proto** , вы увидите здесь и там предупреждающие знаки с просьбой воздержаться от их использования.

Object.setPrototypeOf()и то, и **proto**другое оказывает негативное влияние на производительность в долгосрочной перспективе.

Они разрушают встроенные кэши, поддерживаемые для быстрого доступа к свойствам объектов внутри движка, а также пару других оптимизаций, обсуждение которых выходит за рамки этой главы.

Чтобы узнать больше о внутреннем устройстве V8, движка JavaScript, используемого в Google Chrome, при доступе к свойствам объектов и их разрешении перейдите к основам движка JavaScript: оптимизация прототипов .
Короче говоря, есть потенциальные проблемы с производительностью при его использовании. Обратите внимание, что это не означает, что его использование фатально, Object.setPrototypeOf()а только то, что его следует избегать настолько, насколько это необходимо.

Лучший способ — использовать, Object.create()так как он не изменяет существующий объект, а скорее вводит в код новый объект с заданным прототипом. Это не нарушает данную оптимизацию, сделанную движком.

Не забывайте всегда стараться изо всех сил, чтобы избежать присвоения значения [[Prototype]]существующему объекту. Это может иметь далеко идущие последствия для производительности вашего приложения.


Прототипы объектов
Назад
Обзор: Objects
Далее
Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. В этой статье мы объясним, как работают цепочки прототипов, и рассмотрим, как свойство prototype можно использовать для добавления методов к существующим конструкторам.
Необходимые знания:	Базовая компьютерная грамотность, базовое понимание HTML и CSS, знакомство с основами JavaScript (см. Первые шаги и Строительные блоки) и основы OOJS (см. Введение в объекты).
Цель:	Понять прототипы объектов JavaScript, как работают прототипные цепочки и как добавить новые методы в prototype свойство.
Язык основанный на прототипах?
JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.

Точнее, свойства и методы определяются в свойстве prototype функции-конструктора объектов, а не в самих объектах.

В JavaScript создаётся связь между экземпляром объекта и его прототипом (свойство __proto__, которое является производным от свойства prototype конструктора), а свойства и методы обнаруживаются при переходе по цепочке прототипов.

Примечание: Важно понимать, что существует различие между прототипом объекта (который доступен через Object.getPrototypeOf(obj) или через устаревшее свойство __proto__) и свойством prototype в функциях-конструкторах. Первое свойство является свойством каждого экземпляра, а второе - свойством конструктора. То есть Object.getPrototypeOf(new Foobar()) относится к тому же объекту, что и Foobar.prototype.

Давайте посмотрим на пример, чтобы стало понятнее.

Понимание прототипа объектов
Вернёмся к примеру, когда мы закончили писать наш конструктор Person()- загрузите пример в свой браузер. Если у вас ещё нет работы от последней статьи, используйте наш пример oojs-class-further-exercises.html (см. Также исходный код).

В этом примере мы определили конструктору функцию, например:

function Person(first, last, age, gender, interests) {

  // Определения методов и свойств
  this.name = {
    'first': first,
    'last' : last
  };
  this.age = age;
  this.gender = gender;
  //...см. Введение в объекты для полного определения
}
Copy to Clipboard
Затем мы создаём экземпляр объекта следующим образом:

var person1 = new Person('Bob', 'Smith', 32, 'male', ['music', 'skiing']);
Copy to Clipboard
Если вы наберёте «person1.» в вашей консоли JavaScript, вы должны увидеть, что браузер пытается автоматически заполнить это с именами участников, доступных на этом объекте:


В этом списке вы увидите элементы, определённые в конструкторе person 1 — Person() — name, age, gender, interests, bio, и greeting. Однако вы также увидите некоторые другие элементы — watch, valueOf и т. д. — они определены в объекте прототипа Person (), который является Object.


Итак, что произойдёт, если вы вызываете метод в person1, который фактически определён в Object? Например:

person1.valueOf()
Copy to Clipboard
Этот метод — Object.valueOf()наследуется person1, потому что его конструктором является Person(), а прототипом Person() является Object(). valueOf() возвращает значение вызываемого объекта — попробуйте и убедитесь! В этом случае происходит следующее:

Сначала браузер проверяет, имеет ли объект person1 доступный в нем метод valueOf(), как определено в его конструкторе Person().
Это не так, поэтому следующим шагом браузер проверяет, имеет ли прототип объекта (Object()) конструктора Person() доступный в нем метод valueOf(). Так оно и есть, поэтому он вызывается, и все хорошо!
Примечание: Мы хотим повторить, что методы и свойства не копируются из одного объекта в другой в цепочке прототипов - к ним обращаются, поднимаясь по цепочке, как описано выше.

Примечание: Официально нет способа получить доступ к объекту прототипа объекта напрямую - «ссылки» между элементами в цепочке определены во внутреннем свойстве, называемом [[prototype]] в спецификации для языка JavaScript ( см. ECMAScript). Однако у большинства современных браузеров есть свойство, доступное для них под названием __proto__ (это 2 подчёркивания с обеих сторон), который содержит объект-прототип объекта-конструктора. Например, попробуйте person1.__proto__ и person1.__proto__.__proto__, чтобы увидеть, как выглядит цепочка в коде!

С ECMAScript 2015 вы можете косвенно обращаться к объекту прототипа объекта Object.getPrototypeOf (obj).

Свойство prototype: Где определены унаследованные экземпляры
Итак, где определены наследуемые свойства и методы? Если вы посмотрите на страницу со ссылкой Object, вы увидите в левой части большое количество свойств и методов - это намного больше, чем количество унаследованных членов, доступных для объекта person1. Некоторые из них унаследованы, а некоторые нет - почему это?

Как упоминалось выше, наследованные свойства это те, что определены в свойстве prototype (вы можете называть это подпространством имён), то есть те, которые начинаются с Object.prototype., а не те, которые начинаются с простого Object. Значение свойства prototype - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов.

Таким образом Object.prototype.watch(), Object.prototype.valueOf() и т. д. доступны для любых типов объектов, которые наследуются от Object.prototype, включая новые экземпляры объектов, созданные из конструктора Person() .

Object.is(), Object.keys() и другие члены, не определённые в контейнере prototype, не наследуются экземплярами объектов или типами объектов, которые наследуются от Object.prototype. Это методы / свойства, доступные только в конструкторе Object().

Примечание: Это кажется странным - как у вас есть метод, определённый для конструктора, который сам по себе является функцией? Ну, функция также является типом объекта - см. Ссылку на конструктор Function(), если вы нам не верите.

Вы можете проверить существующие свойства прототипа для себя - вернитесь к нашему предыдущему примеру и попробуйте ввести следующее в консоль JavaScript:
Person.prototype
Copy to Clipboard
Результат покажет вам не много, ведь мы ничего не определили в прототипе нашего конструктора! По умолчанию prototype конструктора всегда пуст. Теперь попробуйте следующее:
Object.prototype
Copy to Clipboard
Вы увидите большое количество методов, определённых для свойства prototype Object'а , которые затем доступны для объектов, которые наследуются от Object, как показано выше.

Вы увидите другие примеры наследования цепочек прототипов по всему JavaScript - попробуйте найти методы и свойства, определённые на прототипе глобальных объектов String, Date, Number и Array, например. Все они имеют несколько элементов, определённых на их прототипе, поэтому, например, когда вы создаёте строку, вот так:

var myString = 'This is my string.';
Copy to Clipboard
В myString сразу есть множество полезных методов, таких как split(), indexOf(), replace() и т. д.

Предупреждение: Важно: Свойство prototype является одной из наиболее противоречивых названий частей JavaScript - вы можете подумать, что this указывает на объект прототипа текущего объекта, но это не так (это внутренний объект, к которому можно получить доступ __proto__, помните ?). prototype вместо этого - свойство, содержащее объект, на котором вы определяете членов, которые вы хотите наследовать.

Снова create()
Ранее мы показали, как метод Object.create() может использоваться для создания нового экземпляра объекта.

Например, попробуйте это в консоли JavaScript предыдущего примера:
var person2 = Object.create(person1);
Copy to Clipboard
На самом деле create() создаёт новый объект из указанного объекта-прототипа. Здесь person2 создаётся с помощью person1 в качестве объекта-прототипа. Это можно проверить, введя в консоли следующее:
person2.__proto__
Copy to Clipboard
Это вернёт объект person1.

Свойство constructor
Каждая функция-конструктор имеет свойство prototype, значением которого является объект, содержащий свойство constructor. Это свойство constructor указывает на исходную функцию-конструктор. Как вы увидите в следующем разделе, свойства, определённые в свойстве Person.prototype (или в общем случае в качестве свойства прототипа функции конструктора, который является объектом, как указано в предыдущем разделе) становятся доступными для всех объектов экземпляра, созданных с помощью конструктор Person(). Следовательно, свойство конструктора также доступно для объектов person1 и person2.

Например, попробуйте эти команды в консоли:
person1.constructor
person2.constructor
Copy to Clipboard
Они должны возвращать конструктор Person(), поскольку он содержит исходное определение этих экземпляров. Хитрый трюк заключается в том, что вы можете поместить круглые скобки в конец свойства constructor (содержащие любые требуемые параметры) для создания другого экземпляра объекта из этого конструктора. Конструктор - это функция в конце концов, поэтому её можно вызвать с помощью круглых скобок; вам просто нужно включить ключевое слово new, чтобы указать, что вы хотите использовать эту функцию в качестве конструктора.
Попробуйте это в консоли:
var person3 = new person1.constructor('Karen', 'Stephenson', 26, 'female', ['playing drums', 'mountain climbing']);
Copy to Clipboard
Теперь попробуйте получить доступ к функциям вашего нового объекта, например:
person3.name.first
person3.age
person3.bio()
Copy to Clipboard
Это хорошо работает. Вам не нужно будет использовать его часто, но это может быть действительно полезно, если вы хотите создать новый экземпляр и не имеете ссылки на исходный конструктор, который легко доступен по какой-либо причине.

Свойство constructor имеет другие применения. Например, если у вас есть экземпляр объекта и вы хотите вернуть имя конструктора этого экземпляра, вы можете использовать следующее:

instanceName.constructor.name
Copy to Clipboard
Например, попробуйте это:

person1.constructor.name
Copy to Clipboard
Примечание: Значение constructor.name может измениться (из-за прототипического наследования, привязки, препроцессоров, транспилеров и т. д.), Поэтому для более сложных примеров вы захотите использовать оператор instanceof.

Изменение прототипов
Давайте рассмотрим пример изменения свойства prototype функции-конструктора — методы, добавленные в прототип, затем доступны для всех экземпляров объектов, созданных из конструктора.

Вернитесь к нашему примеру oojs-class-further-exercises.html и создайте локальную копию исходного кода. Ниже существующего JavaScript добавьте следующий код, который добавляет новый метод в свойство prototype конструктора:
Person.prototype.farewell = function() {
  alert(this.name.first + ' has left the building. Bye for now!');
};
Copy to Clipboard
Сохраните код и загрузите страницу в браузере и попробуйте ввести следующее в текстовый ввод:
person1.farewell();
Copy to Clipboard
Должно появиться всплывающее окно, с именем пользователя, определённым в конструкторе. Это действительно полезно, но ещё более полезно то, что вся цепочка наследования обновляется динамически, автоматически делая этот новый метод доступным для всех экземпляров объектов, полученных из конструктора.

Подумайте об этом на мгновение. В нашем коде мы определяем конструктор, затем мы создаём экземпляр объекта из конструктора, затем добавляем новый метод к прототипу конструктора:

function Person(first, last, age, gender, interests) {

  // определения свойств и методов

}

var person1 = new Person('Tammi', 'Smith', 32, 'neutral', ['music', 'skiing', 'kickboxing']);

Person.prototype.farewell = function() {
  alert(this.name.first + ' has left the building. Bye for now!');
};
Copy to Clipboard
Но метод farewell() по-прежнему доступен в экземпляре объекта person1 - его элементы были автоматически обновлены, чтобы включить недавно определённый метод farewell().

Примечание: Если у вас возникли проблемы с получением этого примера для работы, посмотрите на наш пример oojs-class-prototype.html (см. также это running live).

Вы редко увидите свойства, определённые в свойстве prototype, потому что они не очень гибки при таком определении. Например, вы можете добавить свойство следующим образом:

Person.prototype.fullName = 'Bob Smith';
Copy to Clipboard
Это не очень гибко, так как человека нельзя назвать так. Было бы намного лучше сделать это, создав fullName из name.first и name.last:

Person.prototype.fullName = this.name.first + ' ' + this.name.last;
Copy to Clipboard
Однако это не работает, поскольку в этом случае this будет ссылаться на глобальную область, а не на область функции. Вызов этого свойства вернёт undefined undefined. Это отлично работало с методом, который мы определили ранее в прототипе, потому что он находится внутри области функций, которая будет успешно перенесена в область экземпляра объекта. Таким образом, вы можете определить постоянные свойства прототипа (т. е. те, которые никогда не нуждаются в изменении), но обычно лучше определять свойства внутри конструктора.

Фактически, довольно распространённый шаблон для большего количества определений объектов - это определение свойств внутри конструктора и методов в прототипе. Это упрощает чтение кода, поскольку конструктор содержит только определения свойств, а методы разделены на отдельные блоки. Например:

// Определение конструктора и его свойств

function Test(a, b, c, d) {
  // определение свойств...
}

// Определение первого метода

Test.prototype.x = function() { ... };

// Определение второго метода

Test.prototype.y = function() { ... };

//...и так далее
Copy to Clipboard
Этот образец можно увидеть в действии в примере приложения плана школы Петра Залевы.

Резюме
В этой статье рассмотрены прототипы объектов JavaScript (в том числе и то, как прототип цепочки объектов позволяет объектам наследовать функции друг от друга), свойство прототипа и как его можно использовать для добавления методов к конструкторам и другие связанные с этой статьёй темы.

В следующей статье мы рассмотрим то, как вы можете реализовать наследование функциональности между двумя собственными настраиваемыми объектами.