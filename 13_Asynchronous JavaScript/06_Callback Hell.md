Обратный ад
Руководство по написанию асинхронных программ на JavaScript

Что такое « ад обратного вызова »?
Асинхронный JavaScript, или JavaScript, использующий обратные вызовы, интуитивно сложно понять правильно. Большая часть кода в конечном итоге выглядит так:

fs.readdir(source, function (err, files) {
if (err) {
console.log('Error finding files: ' + err)
} else {
files.forEach(function (filename, fileIndex) {
console.log(filename)
gm(source + filename).size(function (err, values) {
if (err) {
console.log('Error identifying file size: ' + err)
} else {
console.log(filename + ' : ' + values)
aspect = (values.width / values.height)
widths.forEach(function (width, widthIndex) {
height = Math.round(width / aspect)
console.log('resizing ' + filename + 'to ' + height + 'x' + height)
this.resize(width, height).write(dest + 'w' + width + '\_' + filename, function(err) {
if (err) console.log('Error writing file: ' + err)
})
}.bind(this))
}
})
})
}
})
Видите форму пирамиды и все это })в конце? Эй! Это ласково называют адом обратного вызова .

Причина ада обратных вызовов в том, что люди пытаются написать JavaScript таким образом, чтобы выполнение происходило визуально сверху вниз. Эту ошибку совершают многие! В других языках, таких как C, Ruby или Python, ожидается, что все, что происходит в строке 1, завершится до того, как начнет выполняться код в строке 2, и так далее по файлу. Как вы узнаете, JavaScript отличается.

Что такое обратные вызовы?
Обратные вызовы — это просто название соглашения об использовании функций JavaScript. В языке JavaScript нет специальной вещи под названием «обратный вызов», это просто соглашение. Вместо немедленного возврата какого-либо результата, как в большинстве функций, функциям, использующим обратные вызовы, требуется некоторое время для получения результата. Слово «асинхронный», также известное как «асинхронный», просто означает «требует некоторого времени» или «происходит в будущем, а не прямо сейчас». Обычно обратные вызовы используются только при выполнении ввода-вывода, например, при загрузке чего-либо, чтении файлов, общении с базами данных и т. д.

Когда вы вызываете обычную функцию, вы можете использовать ее возвращаемое значение:

var result = multiplyTwoNumbers(5, 10)
console.log(result)
// 50 gets printed out
Однако асинхронные функции, использующие обратные вызовы, ничего не возвращают сразу.

var photo = downloadPhoto('http://coolcats.com/cat.gif')
// photo is 'undefined'!
В этом случае загрузка gif может занять очень много времени, и вы не хотите, чтобы ваша программа приостанавливалась (т. е. «блокировалась») в ожидании завершения загрузки.

Вместо этого вы сохраняете код, который должен выполняться после завершения загрузки, в функции. Это обратный звонок! Вы передаете его downloadPhotoфункции, и она выполнит ваш обратный вызов (например, «перезвонит вам позже»), когда загрузка будет завершена, и передаст фотографию (или ошибку, если что-то пошло не так).

downloadPhoto('http://coolcats.com/cat.gif', handlePhoto)

function handlePhoto (error, photo) {
if (error) console.error('Download error!', error)
else console.log('Download finished', photo)
}

console.log('Download started')
Самое большое препятствие, с которым люди сталкиваются при попытке понять обратные вызовы, — это понимание порядка, в котором выполняются вещи во время работы программы. В этом примере происходят три важные вещи. Сначала handlePhotoобъявляется функция, затем downloadPhotoфункция вызывается и передается в handlePhotoкачестве обратного вызова, и, наконец 'Download started', распечатывается.

Обратите внимание, что метод handlePhotoеще не вызывается, он только что создан и передан как обратный вызов в downloadPhoto. Но он не запустится, пока не downloadPhotoзакончит свою задачу, что может занять много времени в зависимости от скорости интернет-соединения.

Этот пример предназначен для иллюстрации двух важных концепций:

Обратный handlePhotoвызов — это просто способ сохранить некоторые вещи, которые нужно сделать позже.
Порядок, в котором что-то происходит, не читается сверху вниз, он прыгает в зависимости от того, когда что-то завершено.
Как исправить ад обратного вызова?
Ад обратного вызова вызван плохой практикой кодирования. К счастью, написать лучший код не так сложно!

Вам нужно всего лишь следовать трем правилам :

1. Держите свой код поверхностным
   Вот какой-то запутанный браузерный JavaScript, который использует браузер-запрос для выполнения AJAX-запроса к серверу:

var form = document.querySelector('form')
form.onsubmit = function (submitEvent) {
var name = document.querySelector('input').value
request({
uri: "http://example.com/upload",
body: name,
method: "POST"
}, function (err, response, body) {
var statusMessage = document.querySelector('.status')
if (err) return statusMessage.value = err
statusMessage.value = body
})
}
Этот код имеет две анонимные функции. Давайте дадим им имена!

var form = document.querySelector('form')
form.onsubmit = function formSubmit (submitEvent) {
var name = document.querySelector('input').value
request({
uri: "http://example.com/upload",
body: name,
method: "POST"
}, function postResponse (err, response, body) {
var statusMessage = document.querySelector('.status')
if (err) return statusMessage.value = err
statusMessage.value = body
})
}
Как видите, именование функций очень простое и имеет некоторые непосредственные преимущества:

облегчает чтение кода благодаря описательным именам функций
когда случаются исключения, вы получите трассировки стека, которые ссылаются на фактические имена функций, а не на «анонимные».
позволяет перемещать функции и ссылаться на них по именам
Теперь мы можем переместить функции на верхний уровень нашей программы:

document.querySelector('form').onsubmit = formSubmit

function formSubmit (submitEvent) {
var name = document.querySelector('input').value
request({
uri: "http://example.com/upload",
body: name,
method: "POST"
}, postResponse)
}

function postResponse (err, response, body) {
var statusMessage = document.querySelector('.status')
if (err) return statusMessage.value = err
statusMessage.value = body
}
Обратите внимание, что functionобъявления здесь определены в нижней части файла. Это благодаря функции hoisting .

2. Модульность
   Это самая важная часть: любой может создавать модули (также известные как библиотеки). Цитируя Исаака Шлютера (из проекта node.js): «Пишите маленькие модули, каждый из которых делает одну вещь, и собирайте их в другие модули, которые делают большую вещь. Вы не попадете в ад обратных вызовов, если не пойдете туда. ."

Давайте возьмем шаблонный код сверху и превратим его в модуль, разделив его на пару файлов. Я покажу шаблон модуля, который работает либо для кода браузера, либо для кода сервера (или кода, который работает в обоих случаях):

Вот новый файл с именем formuploader.js, который содержит две наши предыдущие функции:

module.exports.submit = formSubmit

function formSubmit (submitEvent) {
var name = document.querySelector('input').value
request({
uri: "http://example.com/upload",
body: name,
method: "POST"
}, postResponse)
}

function postResponse (err, response, body) {
var statusMessage = document.querySelector('.status')
if (err) return statusMessage.value = err
statusMessage.value = body
}
Бит module.exportsявляется примером модульной системы node.js, которая работает в узле, Electron и браузере с использованием browserify . Мне очень нравится этот стиль модулей, потому что он работает везде, очень прост для понимания и не требует сложных конфигурационных файлов или скриптов.

Теперь, когда у нас есть formuploader.js(и он загружается на страницу как тег скрипта после браузера), нам просто нужно его потребовать и использовать! Вот как теперь выглядит код нашего приложения:

var formUploader = require('formuploader')
document.querySelector('form').onsubmit = formUploader.submit
Теперь наше приложение состоит всего из двух строк кода и имеет следующие преимущества:

легче понять новым разработчикам — они не увязнут в чтении всех formuploaderфункций
formuploaderможно использовать в других местах без дублирования кода, и им легко поделиться на github или npm. 3. Обрабатывайте каждую ошибку
Существуют разные типы ошибок: синтаксические ошибки, вызванные программистом (обычно обнаруживаются при первом запуске программы), ошибки времени выполнения, вызванные программистом (код выполнялся, но в нем была ошибка, из-за которой что-то испортилось), ошибки платформы. вызванные такими вещами, как неверные права доступа к файлам, сбой жесткого диска, отсутствие сетевого подключения и т. д. Этот раздел предназначен только для устранения этого последнего класса ошибок.

Первые два правила в первую очередь касаются того, чтобы ваш код был удобочитаемым, а это правило — о том, как сделать ваш код стабильным. Имея дело с обратными вызовами, вы по определению имеете дело с задачами, которые отправляются, отправляются и делают что-то в фоновом режиме, а затем успешно завершаются или прерываются из-за сбоя. Любой опытный разработчик скажет вам, что вы никогда не можете знать, когда возникают эти ошибки, поэтому вы должны планировать их всегда.

С обратными вызовами наиболее популярным способом обработки ошибок является стиль Node.js, где первый аргумент обратного вызова всегда зарезервирован для ошибки.

var fs = require('fs')

fs.readFile('/Does/not/exist', handleFile)

function handleFile (error, file) {
if (error) return console.error('Uhoh, there was an error', error)
// otherwise, continue on and use `file` in your code
}
Если первым аргументом будет the error, это простое соглашение, которое побуждает вас не забывать обрабатывать свои ошибки. Если бы это был второй аргумент, вы могли бы написать подобный код и легче игнорировать ошибку. function handleFile (file) { }

Также можно настроить линтеры кода, чтобы помочь вам не забывать обрабатывать ошибки обратного вызова. Самый простой в использовании называется стандартным . Все, что вам нужно сделать, это запустить $ standardв папке с кодом, и он покажет вам каждый обратный вызов в вашем коде с необработанной ошибкой.

Резюме
Не вкладывать функции. Дайте им имена и разместите их на верхнем уровне вашей программы.
Используйте поднятие функций в своих интересах, чтобы переместить функции «ниже сгиба».
Обрабатывайте каждую ошибку в каждом из ваших обратных вызовов. Используйте стандартный линтер , чтобы помочь вам в этом.
Создавайте многократно используемые функции и размещайте их в модуле, чтобы уменьшить когнитивную нагрузку, необходимую для понимания вашего кода. Подобное разделение кода на небольшие фрагменты также помогает обрабатывать ошибки, писать тесты, вынуждает вас создавать стабильный и документированный общедоступный API для вашего кода и помогает при рефакторинге.
Наиболее важным аспектом предотвращения ада обратных вызовов является перемещение функций в сторону , чтобы поток программы можно было легче понять без необходимости новичкам вникать во все детали функций, чтобы добраться до сути того, что программа пытается сделать. .

Вы можете начать с перемещения функций в конец файла, затем перейти к перемещению их в другой файл, который вы загружаете с помощью относительного требования, например, и, наконец, переместить их в автономный модуль, например . require('./photo-helpers.js')require('image-resize')

Вот несколько практических правил при создании модуля:

Начните с переноса многократно используемого кода в функцию.
Когда ваша функция (или группа функций, связанных с одной и той же темой) станет достаточно большой, переместите их в другой файл и выставьте с помощью module.exports. Вы можете загрузить это, используя относительный запрос
Если у вас есть код, который можно использовать в нескольких проектах, дайте ему собственный файл readme, тесты package.jsonи опубликуйте его на github и npm. У этого конкретного подхода слишком много замечательных преимуществ, чтобы перечислять их здесь!
Хороший модуль небольшой и фокусируется на одной проблеме
Отдельные файлы в модуле не должны быть длиннее примерно 150 строк JavaScript.
Модуль не должен иметь более одного уровня вложенных папок, заполненных файлами JavaScript. Если это так, вероятно, он делает слишком много вещей.
Попросите более опытных программистов, которых вы знаете, показать вам примеры хороших модулей, пока у вас не появится четкое представление о том, как они выглядят. Если для понимания того, что происходит, требуется больше нескольких минут, вероятно, это не очень хороший модуль.
Больше чтения
Попробуйте прочитать мое более подробное введение в обратные вызовы или попробуйте некоторые учебные пособия по nodeschool .

Также ознакомьтесь с руководством по браузеру для примеров написания модульного кода.

Как насчет промисов/генераторов/ES6 и т. д.?
Прежде чем рассматривать более продвинутые решения, помните, что обратные вызовы являются фундаментальной частью JavaScript (поскольку они всего лишь функции), и вам следует научиться читать и писать их, прежде чем переходить к более продвинутым функциям языка, поскольку все они зависят от понимания обратные вызовы. Если вы еще не можете написать поддерживаемый код обратного вызова, продолжайте работать над этим!

Если вы действительно хотите, чтобы ваш асинхронный код читался сверху вниз, вы можете попробовать несколько необычных вещей. Обратите внимание, что это может привести к проблемам с производительностью и/или совместимостью между платформами , поэтому обязательно изучите их.

Промисы — это способ написания асинхронного кода, который по-прежнему выглядит так, как будто он выполняется сверху вниз, и обрабатывает больше типов ошибок из-за рекомендуемого использования обработки ошибок стиля. try/catch

Генераторы позволяют вам «приостанавливать» отдельные функции, не приостанавливая состояние всей программы, что за счет немного более сложного для понимания кода позволяет вашему асинхронному коду выполняться сверху вниз. Проверьте ватт для примера этого подхода.

Асинхронные функции — это предлагаемая функция ES7, которая в дальнейшем будет заключать генераторы и промисы в синтаксис более высокого уровня. Проверьте их, если это звучит интересно для вас.

Лично я использую обратные вызовы для 90% асинхронного кода, который я пишу, и когда все усложняется, я добавляю что-то вроде run-parallel или run-series . Я не думаю, что обратные вызовы, обещания или что-то еще действительно имеют для меня значение, самое большое влияние оказывает сохранение кода простым, а не вложенным и разделенным на небольшие модули.

Независимо от того, какой метод вы выберете, всегда обрабатывайте каждую ошибку и сохраняйте простоту кода .

Помните, только вы можете предотвратить ад обратного вызова и лесные пожары
Вы можете найти исходный код этого на github .
