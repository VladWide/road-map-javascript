Главная > Курсы > JavaScript для продвинутых пользователей > Промисы — Введение
Обещания Введение
Что вы узнаете на этой странице?
Введение в асинхронное программирование
Подводные камни обратных вызовов
Что такое обещания

Файловые API
FileReader
Обещания
Основы

Вступление
Асинхронное выполнение — одна из самых фундаментальных и элементарных концепций JavaScript, но она создает трудности для начинающих разработчиков как в ее понимании, так и в работе с ней.

Архитектура JavaScript использует по существу две вещи для обхода асинхронных операций и отслеживания их завершения или сбоя. Это события и обратные вызовы .

Как мы знаем, событие — это просто действие, происходящее на веб-странице, а обратный вызов — это функция, переданная другой функции в качестве аргумента. Обе эти идеи позволяют обрабатывать асинхронные задачи в языке.

Например, при работе с XMLHttpRequest, мы обрабатываем события для таких вещей, как изменение состояния, прерывание или выполнение запроса. Точно так же при чтении файлов в JavaScript через readfile()функцию filesystemмодуля в среде выполнения Node.js мы передаем обратный вызов readfile(), который затем вызывается после завершения операции чтения файла.

Хотя они предлагают разработчикам превосходное удобство при написании базового асинхронного кода, события и обратные вызовы начинают распадаться по своей синтаксической структуре, как только базовый код становится более сложным. Чем больше кода, тем меньше ремонтопригодность и больше проблем.

В этой главе мы стремимся выявить точные проблемы, связанные со стилем обратного вызова при написании асинхронного кода, а затем увидеть их решение в виде чего-то, что называется обещаниями .

Подводные камни обратных вызовов
Чтобы на практическом уровне обсудить сложности использования обратных вызовов, нам нужен реальный пример, который их использует и сам часто используется. Возможно, лучшим выбором будет AJAX.

AJAX означает асинхронный JavaScript и XML и представляет собой метод асинхронной отправки HTTP-запросов из браузера без необходимости полной перезагрузки страницы. Он широко используется многими крупными веб-приложениями, такими как Facebook, Google и т. д., чтобы добавить совершенно новый уровень интерактивности и модернизма в свои пользовательские интерфейсы.

Подробное руководство по AJAX см. в нашем курсе AJAX .
Давайте рассмотрим очень простой вызов AJAX. Предположим, вы хотите запросить names.txtпоказанный ниже файл с помощью AJAX:

имена.txt
Only one file linked for now.
foods.txt
Код для этого будет примерно таким:

var xhr = new XMLHttpRequest();
xhr.open("GET", "names.txt", true);
xhr.onload = function() {
if (this.status === 200) {
document.write(this.responseText);
}
}
xhr.send();
Теперь, хотя это работает хорошо, как только возникнет необходимость выполнять вложенные запросы AJAX (один в другой), мы получим блок кода, который сложно поддерживать. Пример стоил бы обсуждения.

Представьте, что после успешного запроса names.txtвышеуказанного файла мы хотим отдельно запросить упомянутый в нем файл, foods.txtт.е.

еда.txt
Pizza
Pasta
Cookies
Что нам нужно сделать, чтобы выполнить это, так это обработать ответ names.txt, извлечь из него имя файла, а затем, наконец, запросить его с помощью нового вызова AJAX.

Что-то вроде:

var xhr = new XMLHttpRequest();
xhr.open("GET", "names.txt", true);
xhr.onload = function() {
if (this.status === 200) {
// process the response
var filename = this.responseText.split("\n")[1]; // extract the filename

      // new AJAX request
      var xhr2 = new XMLHttpRequest();
      xhr2.open("GET", filename, true);

      xhr2.onload = function() {
         if (this.status === 200) {
            alert(this.responseText);
         }
      }
      xhr2.send();

}
}
xhr.send();
Здесь мы предполагаем, что names.txtсодержит имя файла во второй строке.
Внутри onloadобработчика первого запроса xhr к names.txt(в строке 3) у нас есть логика для второго запроса xhr к foods.txt, который после завершения вызывает onloadобработчик в строке 12, где мы, наконец, выводим содержимое foods.txtфайла.

Обратите внимание, как отступы становятся все длиннее и длиннее, выталкивая код подуровня все дальше вправо. Кто-то может возразить и сказать, что мы можем создать отдельную функцию и поместить в нее весь код для второго вызова AJAX и, таким образом, избежать отступов, как показано ниже:

function secondRequest(xhr) {
var filename = xhr.responseText.split("\n")[1];

var xhr2 = new XMLHttpRequest();
xhr2.open("GET", filename, true);

xhr2.onload = function() {
if (this.status === 200) {
alert(this.responseText);
}
}
xhr2.send();
}

var xhr = new XMLHttpRequest();
xhr.open("GET", "names.txt", true);
xhr.onload = function() {
if (this.status === 200) {
// process the response
secondRequest(this)
}
}
xhr.send();
Здесь все то же, что и раньше, за исключением того, что на этот раз логика для второго запроса xhr определена в функции secondRequest(); и не напрямую.

Еще лучше, кто-то может придумать следующий код, определяющий только одну функцию для создания нового запроса AJAX с заданным именем файла и обратным вызовом (для запуска после успешного завершения запроса):

function ajaxRequest(filename, callback) {
var xhr = new XMLHttpRequest();
xhr.open("GET", filename, true);
xhr.callback = callback;
xhr.onload = function() {
if (this.status === 200) this.callback();
}
xhr.send();
}

ajaxRequest("names.txt", function(e) {
var filename = this.responseText.split("\n")[1];
ajaxRequest(filename, function() {
alert(this.responseText);
});
});
Свойство callbackпередается объекту xhr (в строке 4), чтобы вызвать его с thisравным xhrобъекту.
Хорошая мысль! Но этого может быть достаточно только до тех пор, пока обработка ошибок и дальнейшие вложенные вызовы AJAX не потребуются в коде. Как только любой из них войдет в игру, игра будет окончена!

Рассмотрим приведенный ниже фрагмент, расширяющий наш предыдущий код AJAX логикой обработки ошибок:

function ajaxRequest(filename, callback, errorCallback) {
var xhr = new XMLHttpRequest();
xhr.open("GET", filename, true);
xhr.callback = callback;
xhr.onload = function() {
if (this.status === 200) this.callback();
}
xhr.onerror = errorCallback;
xhr.send();
}

ajaxRequest("names.txt", function(e) {
var filename = this.responseText.split("\n")[1];

ajaxRequest(filename, function() {
alert(this.responseText);
}, function(e) { console.error("Error!") });

}, function(e) { console.error("Error!") });
Обратите внимание, как onerrorобработчик переопределяется без какой-либо причины - логика обработки ошибок та же самая, т.е. выдает сообщение об ошибке "Error!", однако функции для этого разные!

Простой обходной путь — создать отдельную функцию обработчика ошибок, как показано handleError()ниже, и передать ее отдельным ajaxRequest()функциям:

function handleError() {
console.error("Error!");
}

ajaxRequest("names.txt", function(e) {
var filename = this.responseText.split("\n")[1];
ajaxRequest(filename, function() {
alert(this.responseText);
}, handleError);
}, handleError);
Но даже в этом случае общий синтаксис кода останется загроможденным. Просто взгляните на приведенный выше код — вам не кажется, что он выглядит слишком громоздким ?

Тем не менее, это лишь одна из многих проблем с синтаксисом обратного вызова — на этом история не заканчивается.

На долю секунды представьте, что это foods.txtтакже требует вызова другого файла, такого как pizza.txt. Затем код приблизится к тому, что обычно называют адом обратного вызова:

пицца.txt
Chicken Tikka Pizza
BBQ Pizza
Cheese Pizza
ajaxRequest("names.txt", function(e) {
var filename = this.responseText.split("\n")[1];
ajaxRequest(filename, function() {
var filename = this.responseText.split("\n")[1];
ajaxRequest(filename, function() {
alert(this.responseText);
}, handleError);
}, handleError);
}, handleError);
Посмотрите, как обратные вызовы начинают запутываться и постоянно сдвигаются вправо. С парой из них мы бы просто получили ад обратных вызовов , также известный как пирамида гибели :

func1(function(data) {
func2(function(data) {
func3(function(data) {
func4(function(data) {
// some code
});
});
});
});
Это выглядит некрасиво и, без сомнения, трудно поддерживать.

Включите в него код обработки ошибок, и вы «погрузите себя в настоящую горячую воду» .

Однако это не единственные недостатки использования обратных вызовов — их существует больше; те, которые определенно нуждаются в другом способе достижения. Например, рассмотрим задачу запроса нескольких файлов за один раз, а затем выполнение функции после того, как все они будут полностью получены.

Не торопитесь и попытайтесь некоторое время подумать над этой проблемой в стиле обратного вызова ; посмотреть, где вы в конечном итоге!

Обещания вступают
Решение всех проблем, рассмотренных в разделе выше, осуществляется в рамках концепции промисов . Так что же такое обещание?

Определяя его с точки зрения идеи, стоящей за ним:

Обещание — это средство упрощения задачи написания сложного асинхронного кода.
Но это не то определение, которое точно говорит нам, что такое промис — это, более или менее, просто удобный способ взглянуть на него.

В более технических терминах:

Обещание — это объект, представляющий успех или неудачу данной операции, обычно асинхронной операции.
Хорошо, теперь это может быть слишком много, чтобы переварить за один раз!

С точки зрения непрофессионала, обещание — это просто способ зафиксировать завершение или невыполнение данной задачи. Обычно эта задача является асинхронной — для чего на самом деле предназначены промисы.

Обещания не предназначены для синхронных задач.
«Удержание места» означает, что после того, как обещание выполнит заданную задачу, оно служит для удержания результата, который может быть успешным или неудачным .

Используя этот задержанный результат, программа затем может выполнять соответствующие действия, такие как дальнейшая обработка данных в случае успеха или регистрация ошибки в случае сбоя.

Не беспокойтесь, если вы не поняли ни слова в этом обсуждении. Промисы — это действительно одна из концепций JavaScript, которая вообще не имеет никакого смысла, если и пока вы не поэкспериментируете с ними.

Если определения выходят за рамки вашей головы, что обычно и должно быть, просто пока игнорируйте их. Просто сосредоточьтесь на изучении внутреннего поведения обещаний, и вскоре вы будете писать собственные определения!

Возвращаясь к теме, все утилиты, связанные с промисами в JavaScript, приведены под Promiseинтерфейсом . Любое обещание, которое мы должны создать, всегда должно Promiseтак или иначе использовать интерфейс.

Говоря о том, как на самом деле создать промис и затем работать с ним, мы подробно обсудим детали этого в следующей главе, посвященной промисам JavaScript .

А пока давайте кратко рассмотрим, с какими преимуществами связаны обещания.

Преимущества использования промисов
Во-первых, промисы уменьшают дополнительные уровни отступов, которые мы видели ранее, с помощью механизма присоединения обратных вызовов вместо передачи их другой функции.

Во-вторых, обработка ошибок в промисах гораздо более лаконична и удобна в сопровождении, чем обработка ошибок в обратных вызовах. Промисы основаны на традиционной try..catchмодели, используемой для реагирования на выброшенные исключения, и, таким образом, предлагают разработчикам больше удобства при написании кода обработки исключений.

Кроме того, синтаксис обещания очень тесно связан с английским языком, поэтому связанные асинхронные вызовы кажутся более осмысленными и всеобъемлющими для понимания. В основе этой идеи лежит then()метод, как мы увидим в следующей главе.

И на этом история даже не заканчивается — просто мы будем немного ошеломлены, увидев все мельчайшие плюсы, которые обещания могут предложить нам за один раз. На данный момент лучше не усложнять, оставив остальные идеи для изучения по очереди в следующих главах.

Главная > Курсы > JavaScript для продвинутого уровня > Промисы — Основы
Основы обещаний
Что вы узнаете на этой странице?
Как создать простое обещание
Статусы, состояния и значение промиса
resolve()и reject()функции
Метод then()\_

Обещания
Вступление
Обещания
Викторина по основам

Вступление
Не тратя больше времени на обсуждение абстрактных идей, давайте теперь разберем синтаксис, чтобы создать очень простое обещание, которое вы не нарушите !

Сначала давайте определимся с тем, какую асинхронную операцию мы будем выполнять в нашем промисе. Вспомним из предыдущей главы , что обещание предназначено для упрощения написания асинхронного кода , так что, без всяких сомнений, сначала мы должны его придумать!

Некоторые быстрые варианты — отправить запрос AJAX или установить таймер с помощью setTimeout().

Последний, как мы все знаем, прост в использовании и понимании; и точно так же будет асинхронная операция, которую мы будем выполнять в рамках нашего обещания.

Узнайте, как работать с таймерами setTimeout()в JavaScript .
Очевидно, что на практике асинхронная операция будет более полезной, например запрос AJAX. Однако для демонстрационных целей лучше использовать setTimeout().
Итак, с задачей решено, давайте теперь погрузимся прямо в ее разгадку.

По-видимому, все асинхронные операции завершаются по прошествии определенного времени с момента их выполнения. Для setTimeout()этого время примерно равно значению, переданному в качестве второго аргумента функции.

Для запросов AJAX, хотя мы и не можем приблизительно предположить, сколько времени потребуется для их выполнения, мы можем вместо этого обработать loadсобытие (или аналогичное readystatechangeсобытие) для выполнения этой самой работы.

Проще говоря, каждая асинхронная операция завершается в какой-то момент в будущем — она НЕ завершается сразу . Обратные вызовы и события — это то, что помогает нам отслеживать эти моменты, выполняя на них заданные функции.

Рассмотрим задачу показать лог пользователю через 3 секунды. Для этого напишем примерно следующее:

setTimeout(function() {
console.log("Hello");
}, 3000);
Асинхронная операция здесь — это отсчет таймера, выполняемый внутри браузера в фоновом режиме. Операция завершается вызовом анонимной функции, которая создает журнал консоли (скорее всего, через 3 секунды).

В этом абзаце демонстрируются две идеи, которые будут использованы позже при преобразовании приведенного выше кода в обещание. Сможете ли вы их заметить?
Теперь с операцией решил, что, наконец, время для начала действия!

Простое обещание
Эмпирическое правило при работе с продвинутым JavaScript — в данном случае с обещаниями — никогда не паниковать, видя какой-либо сложный фрагмент кода. Просто постепенно перемещайте взгляд от утверждения к утверждению, расшифровывая цель каждого из них.

В конце концов, теперь вы изучаете продвинутые вещи!

Итак, помня об этом, давайте теперь, наконец, посмотрим, как создать обещание. Рассмотрим следующий код:

var promise = new Promise(function(resolve, reject) {
setTimeout(function() {
resolve("Hello");
}, 3000);
});
Как уже было сказано, не паникуйте, увидев это! Давайте разбираться постепенно, вместе.

Обратите внимание на все выделенные жирным шрифтом фразы в следующем разделе.
Повторяя то, что мы сказали выше, все начинается с решения о том, какую асинхронную операцию выполнять в промисе. В нашем случае это установка тайм-аута в 3 секунды.

Сделав это, мы затем инкапсулируем все необходимые операторы, требуемые операцией, внутри функции . Например, если нашей асинхронной операцией является запрос AJAX, мы просто поместим весь его код в функцию.

Наконец, чтобы закончить, мы передаем эту функцию Promise()конструктору в качестве аргумента .

В терминологии промисов мы называем эту функцию исполнителем .

Исполнитель просто выполняет все операторы, устанавливающие асинхронную операцию, поэтому он так и называется.
Как только обещание создается new Promise()с использованием функции в качестве аргумента, эта функция немедленно выполняется обещанием.

Например, для данной функции f, если мы вызовем new Promise(f), функция fбудет вызвана сразу же, как только будет создано обещание.

Вызов исполнителя, очевидно, настраивает желаемую асинхронную операцию на завершение в какой-то момент в будущем. Когда он завершается, что может быть успешным или неудачным, появляются две специальные функции.

Очень внимательно обратите внимание, что это Promise()функция, которая вызывает исполнителя внутренне — вы передаете ссылку на функцию в качестве аргумента, Promise()который затем может вызывать ее любым способом, который ему нравится .

Это означает, что при вызове исполнителя обещание может передать ему любые аргументы , какие пожелает.

На практике исполнителю действительно передаются два аргумента : один — функция, которая вызывается по завершении асинхронной операции , а другой — функция, вызываемая при сбое асинхронной операции .

Согласно спецификации, первая функция вызывается resolve(), а вторая вызывается reject().

Теперь, прежде чем мы объясним назначение этих функций, давайте сначала немного поговорим обо всей идее, которая к ним приводит.

Состояния обещания
Напомним из приведенного выше обсуждения, что обещание инкапсулирует данную асинхронную операцию и что все асинхронные операции завершаются (успешно или неудачно) в какой-то момент в будущем с момента их выполнения.

Теперь, когда асинхронная операция, лежащая в основе обещания, завершается успешно или неудачно, как, по-вашему, обещание узнает об этом изменении? Как внешний код узнает, что это обещание выполнено или отклонено соответственно?

Здесь возникает понятие государства .

По сути, в любой момент времени данное обещание может находиться в одном из трех состояний: ожидание, выполнение или отклонение .
Ожидание означает, что базовая асинхронная операция все еще продолжается, и об обещании нельзя судить; выполнено означает, что это удалось; в то время как отклонено означает, что он просто потерпел неудачу.

Каждый объект промиса имеет внутренний слот, [[PromiseState]]согласно спецификации, для отражения этого атрибута промиса. Изначально, когда мы вызываем Promise()конструктор, он устанавливается в "pending".

Чтобы заставить его измениться на "resolved"или аналогичным образом "rejected", мы должны вызвать аргументы исполнителя resolve()и reject()соответственно.

Разрешение обещаний выполняется с помощью, resolve()тогда как его отклонение выполняется с помощью reject().
Без этих функций мы не смогли бы разрешить или отклонить обещание, а также выполнить последующие действия. Эти функции не просто изменяют [[PromiseState]]или "resolved"завершают "rejected"промис с заданным значением.

Посмотрим, что это значит...

Значение обещания
Обычно, когда асинхронная операция завершается, она готова с некоторыми данными, которые можно использовать для дальнейших действий.

Например, когда запрос AJAX завершается, он готов с данными ответа в responseTextсвойстве.

Когда асинхронная операция завершается успешно, мы называем это результатом операции; и точно так же, когда он терпит неудачу, мы называем это причиной неудачи.

Теперь, возвращаясь назад, если внешний код знает, что обещание разрешено, то он также должен знать значение, с которым оно было разрешено. То же самое относится и к случаю отказа - если внешний код знает, что обещание отклонено, он также должен знать причину его отказа.

Мы называем это ценностью обещания.

Значение обещания устанавливается путем передачи аргумента функции или . Внутри эти функции помещают это значение во внутренний слот промиса. resolve() reject()[[PromiseValue]]

Думайте об этом естественно — если мы разрешаем промис, вызывая resolve(), то мы также должны указать значение, с которым оно разрешено, т. е. результат базовой асинхронной операции. Этого легко добиться, предоставив аргумент . resolve().
Помните, что не обязательно отправлять аргумент в эти функции — просто когда мы его отправляем, промис разрешается (или отклоняется) вместе с ним — в противном случае принимается значение undefined.
Применив это к приведенному выше коду, когда мы вызываем resolve("Hello")его (в строке 3), статус промиса сначала устанавливается на , "resolved"а затем его значение устанавливается на "Hello".

Теперь, когда мы готовы с промисом, пришло время прикрепить к нему обратный вызов, который будет вызываться после его разрешения. Это достигается с помощью метода then(). Посмотрим, что это такое...

Метод then()\_
Метод then(), доступный для всех экземпляров обещаний через Promise.prototype, используется для выполнения функции, когда обещание разрешается или отклоняется.

Он принимает два аргумента, очень похожих на аргументы исполнителя: функция, которую нужно вызвать после разрешения промиса; и функция для вызова после отклонения обещания.

В спецификации ECMAScript эти обратные вызовы обозначаются как onFulfilled()и onRejected().

Чтобы не усложнять пока, оставив подробные аспекты then()для обсуждения в разделах ниже, просто попытайтесь понять, что then()ставит в очередь обратные вызовы для объекта обещания, которые будут запущены после его разрешения (или отклонения).

Всегда помните, что все имена идентификаторов в JavaScript имеют для них какое -то значение . Если вы задумаетесь на секунду, название thenхорошо соотносится с английским языком. Например, удобно сказать, что doTheAsyncTask()и 'тогда' , как только это завершится, сделайте это с результатом!
Постарайтесь сделать своей привычкой находить интуицию в имени любого нового идентификатора. Это действительно помогает понять назначение идентификатора!
Рассмотрим следующее расширение нашего предыдущего кода, чтобы через 3 секунды создать журнал консоли со значением "Hello":

var promise = new Promise(function(resolve, reject) {
setTimeout(function() {
resolve("Hello");
}, 3000);
});

promise.then(function(msg) {
console.log(msg); // "Hello"
});
Пора объяснить, что здесь происходит...

В строке 7, вызывая, then()мы promiseдаем ей анонимную функцию обратного вызова, которая будет запущена после завершения базовой асинхронной операции, т. е. при resolve()вызове параметра.

Как только resolve("Hello")вызывается в строке 3, примерно через 3 секунды, эта анонимная функция вызывается с тем же аргументом "Hello", который отправляется в resolve().

Эта анонимная функция регистрирует заданный аргумент, как видно из строки 8, и, таким образом, завершает весь этот беспорядок с одним промисом!

Это вся анатомия простого обещания. Да, это было просто!

Просто резюмирую все:

Объект обещания создается вызовом new Promise(),
Он снабжен функцией исполнителя, в которой выполняется некоторая асинхронная операция,
Операция завершается в какой-то момент в будущем, где она либо разрешается, либо отклоняется вызовом resolve()или reject(), соответственно,
then()В тот момент, когда происходит разрешение или отклонение, запускается соответствующая функция обратного вызова, отправленная через .
Более подробная информация будет обсуждаться в следующих разделах, в которых конкретно рассматриваются функция-исполнитель и метод then().

Исполнительная функция
Пока вы работаете с исполнителем, где выполняется асинхронная операция, вы должны знать о технических аспектах, которые он использует под капотом. Давайте поймем это.

Как мы уже говорили ранее, функция-исполнитель немедленно запускается внутренним движком, как только Promise()конструктор вызывается с единицей.

Это может быть подтверждено приведенным ниже кодом:

var promise = new Promise(function(resolve, reject) {
console.log("Hello");
});
Как только он запускается, этот код сразу же регистрируется "Hello"в консоли, что устанавливает подтверждение.

Из этого следует, что, поскольку исполнитель вызывается немедленно, а не ставится в очередь в каких-либо очередях задач, он имеет синхронную природу, аналогичную большинству операторов JavaScript.

Это означает, что длинная процедура внутри исполнителя будет задерживать рендеринг страницы до тех пор, пока он не завершится до конца. Это можно очень легко проиллюстрировать, используя нашу самодельную delay()функцию:

function delay(time) {
var d = new Date();
while (new Date() - d < time) {}
}

var promise = new Promise(function(resolve, reject) {
delay(5000); // delay the page render for 5 seconds
console.log("OK!")
});
Если вы находитесь в реальном окне документа, вы увидите пустой экран примерно на 5 секунд после запуска этого кода. В противном случае в инструментах разработчика и на вкладке консоли вы увидите лог через 5 секунд.

Живой пример ↗

Подробнее об Date()объекте читайте в JavaScript Dates .
Двигаясь дальше, следующее, что нужно понять при написании исполнителя, это то, что мы ранее вызывали resolveи reject, по сути, являются параметрами функции-исполнителя и, следовательно, могут иметь любое имя.

Например, мы можем назвать их succeedи fail; или settleи dismiss; или даже что-то короткое, например, sи f(аббревиатуры для успеха и неудачи).

Это просто зависит от нас, с чем мы хотим работать - resolveи rejectэто всего лишь условные имена!

Далее мы заменяем параметры и на resolveи соответственно :rejectsucceedfail

var promise = new Promise(function(succeed, fail) {
setTimeout(function() {
succeed("Hello");
}, 3000);
});

promise.then(function(msg) {
console.log(msg); // "Hello"
});
Поскольку параметры исполнителя здесь переименованы, для разрешения промиса нам нужно вызвать первый succeedпараметр. Не совершайте ошибку при вызове resolve()— в приведенном выше коде его нет!
Последнее, что осталось обсудить в этом разделе, это то, что если Promise()вызывается без исполнителя или если этот исполнитель не является функцией, генерируется исключение .

Это иллюстрируется следующим образом:

new Promise(); // no executor
new Promise(10); // executor is not a function
Когда функция исполнителя полностью изучена, пришло время перейти к следующей проблеме — then().

И что?
Подробное обсуждение then()было бы неполным, если бы функции resolve()и reject()остались нетронутыми; Аналогичным образом, после мы поймем связь между тремя функциями и то, как они взаимодействуют друг с другом через внутреннюю очередь обратного вызова, поддерживаемую промисом.

Учтите тот факт, что промис может находиться в одном из двух состояний — неустановленном или установленном — во время вызова его then()метода.

Имея это в виду, попытайтесь логически подумать о том, как метод then()будет работать в любом из этих случаев.

Невыполненное обещание
Если then()вызывается, пока обещание еще не выполнено, как вы думаете, что происходит?

Ну, это что-то действительно интересное!

Угадайте, что происходит с переданной функцией обратного вызова, then()когда метод срабатывает в то время, когда его обещание еще не выполнено.

Он вызывается немедленно
Это просто игнорируется
Он ставится в очередь внутри обещания
Итак, вот что происходит...

Вызывая then()объект обещания, мы просто подразумеваем, что данная функция должна быть запущена, когда обещание установлено. Функция предоставляется в качестве аргумента метода.

Теперь, когда обещание не выполнено и мы вызываем then(), мы по-прежнему имеем в виду то же самое. Однако асинхронная операция еще не завершена, поэтому как мы можем запустить обратный вызов, предоставленный методу?

Мы не можем! И мы также не можем просто игнорировать это - иначе было бы бесполезно звонить then()до расчетов обещаний.

Единственный выход — временно сохранить данный обратный вызов в промисе и запустить его, как только он будет установлен (вызовом resolve()или reject()).
Итак, вы спрашиваете, каков механизм сохранения обратного вызова? Давайте обсудим это...

Как сохраняются обратные вызовы?
Каждый объект промиса внутренне поддерживает две очереди обратного вызова: одна содержит все функции для запуска при его разрешении, а другая содержит все функции для запуска при его отклонении.

Назовем первое: successCallbackQueue, а второе: failureCallbackQueue. Изначально оба это пустые списки.

Однако при вызове then()эти списки заполняются — заданные аргументы обратного вызова выстраиваются в соответствующие очереди один за другим. И с выполнением обещания эти очереди снова опустели.

Когда resolve()вызывается параметр исполнителя, он сначала проверяет наличие обратных вызовов в successCallbackQueue; удаление из очереди и выполнение их, если они существуют. Затем, как мы знаем, он приступает к [[PromiseState]]своему аргументу."resolved"[[PromiseValue]]

С другой стороны, reject()сначала проверяется наличие обратных вызовов в failureCallbackQueue; удаление из очереди и выполнение их, если они существуют; а затем устанавливает и [[PromiseState]]на свой аргумент."rejected"[[PromiseValue]]

Давайте разберемся во всем этом под капотом нашего предыдущего кода:

var promise = new Promise(function(resolve, reject) {
setTimeout(function() {
resolve("Hello");
}, 3000);
});

promise.then(function(msg) {
console.log(msg); // "Hello"
});
Так что здесь происходит?

Сначала после выполнения данного исполнителя создается новое обещание, которое устанавливает тайм-аут для завершения и, следовательно, разрешает обещание через 3 секунды.

Тем временем это завершается, then()вызывается в строке 7 с анонимной функцией в качестве первого аргумента. Поскольку это первый аргумент, а обещание еще не выполнено, эта анонимная функция ставится в очередь на successCallbackQueue.

Наконец, через 3 секунды resolve()вызывается функция тайм-аута в строке 3, которая, в свою очередь, запускает функцию, сохраненную в successCallbackQueue.

Таким образом, мы "Hello"регистрируемся!

Выполненное обещание
Все предельно просто, когда then()вызывается в то время, как обещание исчерпано.

Угадайте, что происходит с переданной функцией обратного вызова, then()когда метод срабатывает в момент выполнения обещания.

Он вызывается немедленно
Это просто игнорируется
Он ставится в очередь внутри обещания
Если обещание выполнено, вызов then()просто немедленно активирует переданный аргумент . Просто нет единой причины сначала ставить в очередь обратный вызов где-нибудь, а затем выполнять его - это даже не имеет смысла!

Но одна вещь, которую вы должны знать, это то, что обратный вызов не запускается синхронно. Скорее, он запускается асинхронно , т. е. он будет отложен до тех пор, пока стек вызовов не будет свободен.

Рассмотрим код ниже:

var promise = new Promise(function(resolve, reject) {
resolve("Hello");
});

promise.then(function(msg) {
console.log(msg); // "Hello"
});

console.log("Bye");
до свидания
Привет
Вы можете подумать, что мы допустили опечатку в письме "Bye"выше "Hello"в консоли; но это не опечатка — это странная правда асинхронных операций!

Поскольку обратный вызов, передаваемый в then()fires асинхронно, будет ждать, пока все синхронные задачи не будут выполнены во всем скрипте, а стек вызовов внутреннего механизма JavaScript не станет пустым.

Это то, что происходит в коде выше.

Обещание создается и немедленно разрешается внутри исполнителя.
После того, как это then()вызывается, и аналогичным образом (поскольку его промис выполнен) его onFulfilledобратный вызов выстраивается в очередь задач движка JavaScript.
Далее делается консольный лог с надписью "Bye". Это завершает выполнение основного скрипта, т. е. стек вызовов теперь готов для выполнения вещей в очереди задач.
Функция onFulfilled()входит в стек вызовов и, следовательно, выполняется. Это приводит к тому, что во втором журнале говорится "Hello".
Таким образом, мы получаем лог-последовательность, "Bye"а затем "Hello".

Цепочка обещаний
Что вы узнаете на этой странице?
Что такое цепочка
Как цепочка работает внутри
Практический пример

Обещания
Викторина по основам
Обещания
Викторина по цепочке

Что такое цепочка?
Да, промисы в JavaScript великолепны, но это не так до тех пор, пока мы не откроем концепцию цепочек . Но что такое цепочка?

Цепочка относится к понятию последующего вызова then()обещания, возвращаемого then().
Звучит безумно? Давайте обсудим это!

Вспомним из предыдущей главы, что метод then()отправляет обратный вызов внутри очереди в своем промисе, который будет выполняться в момент установления (разрешения или сбоя).

Вся идея звучит вполне разумно: « doSomeAsyncTask()а потом , как только это завершится, сделать это с результатом» . Проще говоря, then()запускает обратный вызов только после того, как его обещание владельца будет разрешено.

Говоря о возвращаемом значении, оцените тот факт, что then()возвращается новое обещание , расчет которого зависит от вызова и, следовательно, завершения предоставленного аргумента обратного вызова.

Когда мы вызываем then()промис pс обратным вызовом с заданным аргументом, создается и возвращается новый промис, который устанавливается только при запуске обратного вызова (и это происходит только после того, как основной промис pустанавливается).

Это похоже на то, что мы сейчас говорим: ' doSomeAsyncTask(), затем сделайте это с результатом; и как только это будет сделано; тогда дальше делай так» .

Посмотрите, как мы дважды использовали слово «тогда» .
Этот возврат обещанияthen() позволяет выполнять последующие then()вызовы его выражения вызова; и, таким образом, вся идея цепочки .

Как работает цепочка?
Цепочка промисов не так проста, как кажется. Внутри метода выполняются множественные проверки, then()после чего принимается решение о том, как будет урегулировано возвращаемое обещание и с каким значением, и как будут урегулированы даже последующие обещания.

В этом разделе мы разберемся со всеми техническими деталями связывания промисов с использованием этого then()метода, прежде чем перейти к рассмотрению некоторых реальных примеров по этой теме.

Как мы знаем из предыдущей главы « Основы промиса», если then()вызывается, пока его промис еще не выполнен, обратные вызовы ставятся в очередь внутри — для выполнения, когда промис устанавливается в будущем.

Теперь, что происходит после этого:

Создается новое обещание; его ссылка сохраняется внутри в другой очереди; и, наконец, возвращается методом.
Но зачем нам возвращать еще одно обещание?

Что ж, подумайте логически — если асинхронная задача, заключенная в объект обещания, завершается и аналогично then()срабатывает ее обратный вызов, возможно, нам нужно выполнить вторую асинхронную операцию в этот момент.

Неудивительно сказать, что: « doFirstAsyncTask()и затем, как только он завершится doSecondAsyncTask()» .
Таким образом, кажется разумным вернуть новое обещание, вызвав then(), чтобы зафиксировать возможное завершение соответствующих действий обратного вызова.

Согласно спецификации, этому возвращенному обещанию дается имя производное обещание . В последующем обсуждении мы будем использовать это имя для ссылки на любое обещание, возвращаемое then().

Ссылка на этот производный промис сохраняется внутри основного промиса точно так же, как сохраняется обратный вызов onFulfilled(или onRejected), учитывая, что основной промис все еще не выполнен.

Каждый вызов then()создает отдельное обещание, которое зависит от обратных вызовов, предоставляемых этому конкретному then()методу.

Это означает, что каждый из нескольких then()вызовов промиса pбудет возвращать совершенно новый промис , который будет установлен, когда соответствующие действия обратного вызова будут завершены.

Например, вызов p.then(f1, r1)вернет обещание, которое будет зависеть от завершения действия f1(или r1) для его разрешения (или отклонения). Точно так же вызов p.then(f2, r2)вернет другое обещание, но на этот раз в зависимости от обратного вызова f2(или r2).

Это означает, что каждый вызов then()с данными onFulfilledи onRejectedаргументами ставит в очередь обратные вызовы и вместе с ними ссылку на производное обещание внутри основного обещания.

Давайте также поговорим о случае, когда then()вызывается после расчета промиса.

Сначала выполняется соответствующий обратный вызов; затем его возвращенное или выброшенное значение становится значением производного обещания и, следовательно, используется для его урегулирования; прежде чем, наконец, вернуть это производное обещание.

Если обратный вызов возвращает другой объект обещания, используется немного другой механизм, как мы увидим ниже.

Расчет возвращенного обещания
По сути, когда обратный вызов, переданный в then()полностью, выполняется, его соответствующее производное обещание устанавливается с его возвращаемым (или брошенным) значением.

Единственный случай, когда все немного по-другому, это когда обратный вызов возвращает сам промис — в этом случае возвращенный промис управляет производным промисом.

В основном есть три возможных результата запуска обратного вызова, переданного then():

Возврат не обещанного значения
Генерация исключения
Возврат обещания
Давайте подробно обсудим все эти три возможных исхода.

Необещающая ценность
Если обратный вызов возвращает не обещанное значение, например число, строку, массив и т. д., возвращаемое обещание выполняется с этим значением.

Ниже приведена иллюстрация:

var p = new Promise(function(resolve, reject) {
resolve("Data1");
});

var p2 = p.then(function(data) {
// callback returns a non-promise value
// in this case a string
return "Data2";
});

console.log(p2);
Обещание {<разрешено>: "Data2"}
Промис pсоздается и тут же выполняется в строке 2, после чего на then()нем вызывается метод. Поскольку pустановлено, переданный обратный вызов выполняется сразу же, возвращая значение "Data2". В результате производное обещание, сохраненное в p2, должно быть выполнено со значением "Data2".

Рассмотрим другой пример ниже:

var p = new Promise(function(resolve, reject) {
reject("Sorry");
});

var p2 = p.then(null, function(data) {
// callback returns a non-promise value
// in this case a string
return "OK";
});

console.log(p2);
Обещание {<решено>: "ОК"}
Как и раньше, промис pсоздается, но на этот раз сразу же отклоняется в строке 2, после чего для него then()вызывается метод. Поскольку pустановлено, переданный обратный вызов выполняется сразу же, возвращая значение "OK". Это приводит к тому, что производное обещание снова выполняется со значением "OK".

Это просто:

Независимо от того, когда срабатывает обратный вызов, если он возвращает значение, отличное от промиса, он выполнит соответствующий производный промис с этим значением.
Возникло исключение
Если обратный вызов выдает исключение, например throw new Error("Sorry"), возвращенное обещание отклоняется с этим значением (или, лучше сказать, по этой причине).

Ниже приведена иллюстрация:

var p = new Promise(function(resolve, reject) {
resolve("OK");
});

var p2 = p.then(function(data) {
// callback throws an error
throw "Sorry";
});

console.log(p2);
Обещание {<отклонено>: "Извините"}
Промис pсоздается и тут же выполняется в строке 2, после чего на then()нем вызывается метод. Поскольку pустановлено, переданный обратный вызов выполняется сразу же, выбрасывая значение "Sorry". Это приводит к тому, что производное обещание, сохраненное в p2, впоследствии отклоняется со значением "Sorry".

Подобно этому, рассмотрим пример ниже:

var p = new Promise(function(resolve, reject) {
reject("Sorry");
});

var p2 = p.then(null, function(data) {
// callback throws an error
throw "Sorry again";
});

console.log(p2);
Обещание {<отклонено>: "Извините"}
Здесь все то же, что и раньше, за исключением того, что первое обещание pтеперь отвергается со значением "Sorry".

Это приводит к выполнению второго аргумента, для then()которого выдается сообщение об ошибке "Sorry again". Следовательно, производное обещание отклоняется со значением "Sorry again".

Значение обещания
Если обратный вызов сам возвращает промис, у нас есть особый случай — промис, возвращаемый then()соблюдает результат этого промиса.

Другими словами, если возвращенное обещание выполняется, производное обещание также выполняется; если оно отклонено, производное обещание также будет отклонено; и если оно находится в ожидании, производное обещание также помещается в состояние ожидания.

Рассмотрим следующий код:

var p = new Promise(function(resolve, reject) {
resolve("OK");
});

var p2 = p.then(function(data) {
// callback returns a promise
return new Promise(function(resolve, reject) {
resolve(data + " Bye");
});
});

console.log(p2);

Практический пример
Да, цепочка определенно является отличным способом выполнения последовательных асинхронных процедур, одна за другой, с очень аккуратным синтаксисом.

Выше мы видели пару примеров, которые иллюстрировали идею цепочки со всех точек зрения, но все же оставили ответ на вопрос: есть ли реальное использование объединения промисов в цепочку?

Давайте выполним этот вопрос!

Можете ли вы вспомнить задачу «вложенные запросы AJAX», которую мы выполняли в главе « Введение в промисы»? Это одно приложение - запрос файла; затем, как только он будет получен, проанализируйте его; и в конечном итоге сделать еще один запрос после него.

Раньше мы решали эту задачу с помощью обратных вызовов, которые создавали синтаксический беспорядок в коде, но теперь мы решим ее, используя концепцию цепочки промисов. Рассмотрим код ниже:

Сделайте своей привычкой уметь декодировать длинные строки кода — это действительно поможет в этом курсе.
Чтобы увидеть содержание, names.txtпожалуйста, обратитесь к промисам Введение .
var request1 = new Promise(function(resolve, reject) {
var xhr = new XMLHttpRequest();
xhr.open("GET", "names.txt", true);
xhr.onload = function(e) {
if (this.status === 200) { resolve(this); }
}
xhr.send();
});

var request2 = request1.then(function(data) {
// extract the filename from names.txt
var filename = data.responseText.split("\n")[1];

    // second async operation
    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", filename, true);
        xhr.onload = function(e) {
            if (this.status === 200) { resolve(this); }
        }
        xhr.send();
    });

});

request2.then(function(data) {
alert(data.responseText);
});
Живой пример ↗

В промисе request1мы отправляем и обрабатываем наш первый AJAX-запрос к names.txt. Когда этот запрос завершается, мы вызываем resolve()объект xhrв качестве аргумента (в строке 5).

Это приводит к вызову then()обратного вызова, указанному в строке 10, который обрабатывает xhrответ и, в свою очередь, отправляет второй запрос, используя его.

Аргумент dataв строке 10 — это xhrобъект в строке 2.
Обратный вызов возвращает другое обещание, сохраненное в формате request2. Когда этот второй запрос также завершается request2, выполняется, в конечном итоге выполняется обратный вызов в строке 25, который предупреждает об ответе на этот второй запрос.

Короче говоря, мы связали два промиса request1и request2вместе со вторым зависели от исполнения первого. Как вы, возможно, уже поняли, цепочка действительно является чрезвычайно мощным и изящным способом выполнения последовательных асинхронных операций.

Перепишите приведенный выше код, используя функцию makeRequest(), которая принимает путь к файлу и возвращает обещание, завершающее запрос AJAX.

Ниже приведен шаблон, настроенный для вас:

function makeRequest(filepath) {
// write your code here
}
Аргумент filepathздесь представляет собой строку, содержащую путь к запрашиваемому файлу (который вы можете напрямую передать open()методу).

Двигаемся дальше..
Подводя итог, цепочка имеет решающее значение для понимания всей цели промисов в ядре. Если вы научитесь связывать цепочки, то вы сможете получить буквально все, что угодно в промисах. Поверьте!

В частности, вы должны знать, что then()возвращает новый объект обещания, который делает возможной всю идею цепочки; и механизм, который работает внутри метода, посредством которого сохраняются ссылки на производные промисы.

Итак, чтобы закончить, убедитесь, что вы поняли все в этой главе и, следовательно, можете пройти следующий тест со 100% результатом. Продолжайте учиться и продолжайте делать себя лучше и лучше!

Обещает обработку ошибок
Что вы узнаете на этой странице?
Что такое обработка ошибок
Как обрабатывать ошибки в JavaScript
Обратный onRejected()вызов
Метод catch()\_

Обещания
Викторина по цепочке
Буферы
Основы

Вступление
Одной из самых больших проблем сложных приложений, будь то веб-приложения или настольные приложения, является эффективная обработка ошибок.

Это требует использования обычных try..catchоператоров, связанных с throwключевым словом; помимо прослушивания errorсобытий, выкладывания многочисленных ifпроверок в коде и многого другого на этом пути.

Иногда также требуется передача обратных вызовов для запуска при возникновении каких-либо ошибок. Когда дело обстоит именно так, а код в целом достаточно сложен, то использование обратного вызова просто означает написание кода, который в конечном итоге приведет к неуправляемому беспорядку — как подробно обсуждалось в главе « Введение в промисы».

Лучшей альтернативой является использование обещания!

В этой главе мы познакомим вас с catch()методом, унаследованным всеми промисами, и посмотрим, чем он аналогичен второму аргументу для then(), и как использовать все эти возможности для обработки ошибок, возникающих в завернутой асинхронной операции.

Давай начнем!

Что такое обработка ошибок?
Мы начнем с ответа на вопрос, что такое обработка ошибок, используя наш самый любимый пример, то есть AJAX .

Предположим, вы делаете запрос к какому-то случайному файлу на вашем сервере, используя XMLHttpRequest()ядро ​​AJAX. Как вы думаете, какие ошибки могут возникнуть во всем цикле запрос-ответ?

Сделайте это как быстрое упражнение — это даст вам хорошую разминку по теме!

Назвать несколько:

Запрос может быть сделан к несуществующему файлу, и в этом случае сервер отправит код состояния 404, Not Found.
Сценарий сервера на бэкэнде может иметь недопустимый синтаксис, и в этом случае он ответит статусом 500 Internal Server Error.
Сеть клиента может быть отключена, и в этом случае errorсобытие будет отправлено.
Запрос может нарушить политику CORS, и в этом случае errorсобытие снова будет запущено.
и так далее....

На самом деле это зависит от самого приложения — например, его можно настроить для анализа ответа JSON, а затем считывать свойство анализируемого объекта, чтобы определить статус ответа.

Как бы то ни было, главное здесь то, что ошибки могут возникать в любой асинхронной операции, и поэтому нам необходимо написать код, который эффективно их обрабатывает.

Как обрабатывать ошибки? Ну это элементарно!

Обработка ошибок в JavaScript обычно осуществляется двумя вещами: событиями и условными операторами .
Такие события, как errorи abort, часто возникают даже в простейших приложениях; аналогичным образом обычно предоставляются обработчики onerror, onabortчтобы в конечном итоге реагировать на каждый случай.

Точно так же часто нужно размещать условные проверки в порядке целевых ошибок — например, проверяя statusсвойство XMLHttpRequest()объекта по значению 200в loadсобытии, мы можем сгенерировать исключение, как только узнаем, что оно не равно 200.

В качестве другого примера: мы можем проверить доступность XMLHttpRequest()API и, следовательно, выдать исключение, если оно не поддерживается.
Итак, теперь, когда мы знаем, как обрабатывать ошибки в программировании, пришло время заняться реализацией этого в промисах.

Отклонение обратного вызова
Вспомните then()метод и аргументы обратного вызова, которые мы ему предоставляем: первый — это onFulfilledобратный вызов, который срабатывает после выполнения обещания, а второй — onRejectedобратный вызов, который срабатывает после отклонения обещания.

Если onRejectedпредусмотрено; ну и хорошо, но если это не так, то "Thrower"аргументом по умолчанию считается обратный вызов.

Вопрос в том, когда данное обещание отвергается!

Что ж, есть два способа отклонить обещание: один — вызвать reject()обратный вызов , переданный исполнителю, а другой — явно вызвать исключение внутри исполнителя, используя throwключевое слово.

Принцип работы последнего описывается следующим образом:

Когда Promise()создается экземпляр конструктора, он немедленно выполняет предоставленную функцию-исполнитель внутри tryблока, как в приведенном ниже коде:

function Promise(executor) {
// invoke the executor function
try { executor(); }
catch(e) { reject(e); }
}
Соответствующий catchблок вызывает ту же reject()функцию, переданную исполнителю, и передает ей аргумент ошибки e, как показано выше.

Это означает, что любые выброшенные исключения внутри исполнителя вызовут отклонение соответствующего промиса с выброшенным значением.

Рассмотрим пару примеров.

Ниже приведен код, иллюстрирующий отказ от обещания, сделанный явным вызовом reject()аргумента:

var p = new Promise(function(resolve, reject) {
setTimeout(function() {
reject("Sorry");
}, 3000);
});
Здесь, если мы зарегистрируем объект обещания pчерез 3 секунды, мы получим что-то похожее на следующее:

Обещание {<отклонено>: "Извините"}
Если мы хотим, мы также можем передать обратный вызов для then()обработки отклонения обещания через 3 секунды. Это показано ниже:

p.then(null, function(error) {
console.log("An error occurred: " + error);
});
Второй аргумент здесь — анонимная функция, которая регистрирует сообщение об ошибке в консоли при вызове примерно через 3 секунды.

Произошла ошибка: Извините
Напомним, что второй аргумент then()имеет дело с ошибками; НЕ первый, который в данном случае установлен на null(это не требуется для примера, поэтому нет смысла его давать).

Теперь для второго случая — явного создания исключения в промисе — рассмотрим код ниже:

var p = new Promise(function(resolve, reject) {
setTimeout(function() {
throw "Sorry";
}, 3000);
});
Хотя синтаксически это отличается, этот код делает то же самое, что и код, показанный выше с reject(). Когда оператор throw "Sorry"выполняется, поток управления переходит к внутреннему catchблоку, который затем вызывает reject()функцию со значением throw "Sorry".

Здесь мы снова можем присоединить к промису обратный вызов p, который будет работать точно так же, как и в предыдущем примере.

p.then(null, function(error) {
console.log("An error occurred: " + error);
});
Произошла ошибка: Извините
Двигаясь дальше, как мы знаем из предыдущей главы о цепочках обещаний , then()возвращается обещание, которое зависит от соответствующего переданного обратного вызова для завершения.

В случае, когда он сам выдает ошибку, возвращенное обещание отклоняется с выброшенным значением.

Рассмотрим код ниже:

var p = new Promise(function(resolve, reject) {
resolve("OK");
});

var p2 = p.then(function(data) {
throw "Sorry";
});

console.log(p2);
Обещание {<отклонено>: "Извините"}
Посмотрите, как основное обещание pразрешается, а полученное путем вызова then()ie p2отклоняется просто потому, что обратный вызов выдает ошибку.

Производное обещание отклоняется со значением , если в соответствующем обратном вызове выдается vисключение .vthen()
В тех же строках мы также можем вернуть обещание в обратном вызове, которое в конечном итоге будет отклонено, и, таким образом, производное обещание также будет отклонено:

var p = new Promise(function(resolve, reject) {
resolve("OK");
});

var p2 = p.then(function(data) {
// return a rejected promise
return new Promise(function(resolve, reject) {
reject("Sorry");
});
});
Если мы зарегистрируемся p2через некоторое время здесь, мы получим что-то похожее на следующее:

Обещание {<отклонено>: "Извините"}
Это происходит потому, что, когда then()обратный вызов возвращает сам промис, соответствующий производный промис имитирует возвращенный промис — в данном случае p2имитирует промис в строке 7.

Теперь возвращаясь к сценарию, в котором внутри обратного вызова для генерируется явное исключение then(), у нас есть удивительная концепция, вытекающая из этой очень простой идеи, которую мы собираемся исследовать далее.

Прежде всего, нам важно понять, что если мы не обеспечим обратный вызов с ошибкой then(), метод по умолчанию будет использовать его для "Thrower"функции, которая просто выдаст исключение со значением обещания.

Рассмотрим код ниже:

var p = new Promise(function(resolve, reject) {
reject("Oops!");
});

p.then(null, function(error) {
throw error;
});
Это то же самое, что написать следующее (с then()опущенным вторым аргументом на этот раз):

var p = new Promise(function(resolve, reject) {
reject("Oops!");
});

p.then(null);
Для получения дополнительной информации об аргументах по умолчанию для then(), пожалуйста, прочтите Основы промисов .
Поняв это, попробуйте решить задачу ниже и посмотрите, насколько хорошо вы усвоили промисы в целом!

Какой лог будет сделан в консоли следующим кодом? Поясните свой ответ.

Обычная ловля
Этот метод then()хорошо работает и хорошо звучит при создании обратного вызова для объекта-обещания.

Однако когда дело доходит до обратного вызова с ошибкой, он не выглядит таким значимым, особенно в случаях, когда несколько асинхронных операций должны обрабатываться одним обратным вызовом.

Например, рассмотрим код ниже:

var p = new Promise(function(resolve, reject) {
someAsyncOperation();
}).
then(function(data) {
someOtherAsyncOperation();
}).
then(function(data) {
someOtherAsyncOperation2();
}).
then(null, function(error) {
alert("An error occurred: " + error);
});
Обратите внимание, что последний then()метод выполняет работу по обработке любых ошибок, возникающих в восходящей цепочке промисов, но не делает этого сразу.

Кажется ли, что последний then()вызов в приведенном выше коде обрабатывает ошибки? Он визуально передает вам это сообщение?
Причина, по которой это происходит, заключается в том, что мы не совсем привыкли к именам идентификаторов, thenкоторые служат для перехвата любых сгенерированных исключений. Этой цели хорошо служит условное название «поймать» .

Более того, если вы обратите внимание, вы увидите, что когда наша задача состоит только в обработке ошибок, then()независимо от того, требует ли мы передать два аргумента - один может быть nullили undefined, а второй должен быть функцией обработки ошибок.

Другими словами, then()вынуждает нас упоминать как минимум два аргумента даже в случаях обработки ошибок.

Следовательно, к чему все это привело, так это к тому, что команда разработчиков ES6 дала метод промисам catch(). Давайте обсудим это!

Для заданной f()функции

catch(f)точно синоним then(null, f).
В методе catch()нет ничего нового ; просто ложка синтаксического сахара над мощным then()методом!

Ниже мы продемонстрируем пару примеров использования этого метода.

Здесь мы используем catch()для обработки очень простого отклонения обещания.

var p = new Promise(function(resolve, reject) {
setTimeout(function() {
reject("Sorry");
}, 3000);
});

p.catch(function(error) {
console.log("An error occurred: " + error);
});
catch()принимает только один аргумент, т. е. onRejected()обратный вызов для запуска при отклонении основного обещания.
Напротив, ниже мы используем этот метод гораздо более полезным способом — тот, который показан в начале этого раздела, т. е. для обработки ошибок в цепочке промисов:

var p = new Promise(function(resolve, reject) {
someAsyncOperation();
}).
then(function(data) {
someOtherAsyncOperation();
}).
then(function(data) {
someOtherAsyncOperation2();
}).
catch(function(error) {
alert("An error occurred: " + error);
});
Посмотрите, как последний catch()вызов требует от нас передачи только одного аргумента, т. е. обратного вызова для обработки ошибок, в отличие от передачи дополнительного nullзначения в then().

В заключении
На этом этапе вы должны хорошо разбираться в нескольких вещах, например, как catch()работает внутри, как он может обрабатывать ошибки, возникающие где-либо во всей цепочке промисов, и так далее.

Вы также оцените тот факт, что это не волшебство в том, catch()чтобы иметь возможность обрабатывать цепочки обещаний с ошибками; вместо этого это магия "Thrower"функции, которая выдает ошибки и, таким образом, заставляет их двигаться вниз по течению в catch()метод!

Короче говоря, обработка ошибок имеет решающее значение для программирования и так же важна для промисов в JavaScript. Хотя обратные вызовы синтаксически хорошо работают с простыми ошибками, как только основная асинхронная операция становится более сложной, они начинают терять свою суть.

Таким образом, лучшим решением для сложных вариантов использования является использование промисов и методов обработки ошибок внутри них.
