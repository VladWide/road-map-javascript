Закрытие функций JavaScript
Что вы узнаете на этой странице?
Что такое замыкания
Что такое лексическое окружение
Атрибут [[Scopes]]в Chrome
Сохранение локальных окружений функций
Практическое применение замыканий

Функции
Аргументы
Функции
Викторина по замыканиям

Вступление
В главе « Основы функций JavaScript » мы кратко познакомились с концепцией замыкания функции. Замыкания — одна из самых полезных и красивых идей функций в JavaScript и многих других языках, которые поддерживают первоклассные функции и основаны на системе лексической области видимости.

Не беспокойтесь, если вы не знакомы с термином «система лексической области видимости» . Эта глава призвана прояснить всю путаницу, которая может возникнуть у вас в связи с замыканиями, путем подробного описания каждого их аспекта до сути.

Мы увидим, что такое лексические окружения , как работает лексическая область видимости , как разрешаются имена внутри функций, [[Scope]]внутренний атрибут и множество других вещей, связанных с замыканиями.

Давай начнем...

Что такое замыкания?
Давайте начнем с определения концепции, чтобы получить представление о том, что именно является замыканием.

Функция вместе с ее лексическим окружением в совокупности называется замыканием.
По определению, все функции в JavaScript образуют замыкания. Просто некоторые из них оказываются более полезными и заметными , чем другие. Мы увидим все эти детали в разделах ниже.

Еще раз повторюсь, вам не нужно беспокоиться о том, чтобы усвоить каждый бит этого определения прямо сейчас. Мы рассмотрим каждую часть определения одну за другой и убедимся на 100%, что к концу этой главы вы действительно будете знать, что такое замыкание.

Замыкания не так просты, чтобы их можно было понять, не прикладывая ни малейших усилий, и их даже не так сложно понять годами.

В следующем разделе мы объясним одну из самых фундаментальных идей замыканий — лексическое окружение .

Что такое лексическое окружение?
Самым большим источником путаницы в понимании замыканий является термин «лексическое окружение» или просто слово «лексический» .

Что ж, на самом деле это представляет собой чрезвычайно элементарную концепцию. Давайте разбираться...

В информатике,

Термин «лексический» означает просто «исходный код» или, другими словами, «относящийся к тексту программы» .
Значит ли это, что лексическое окружение должно что-то делать с исходным кодом программы?

Определенно да!

Проверим дальше...

Рассмотрим код ниже:

var a = 'static';

function f1() {
console.log(a);
}

function f2() {
var a = 'dynamic';
f1();
}

f2();
Как вы думаете, что будет на выходе этого кода? Подумайте очень тщательно, потратив столько времени, сколько вам нужно.

Пришло время раскрыть ответ: он « статичен» .

Удивлен?

Что ж, любой, кто начинает изучать JavaScript, не имея опыта работы с языком программирования, который также основан на модели лексической области видимости, должен это сделать.

Вот что вы могли подумать:

Глобальная переменная aобъявляется и инициализируется значением 'static'. Затем создаются две функции f1()и .f2()
Далее f2()вызывается.
Он создает локальную переменную aи присваивает ей значение 'dynamic'.
После этого f1()называется. Заявление console.log(a)встречается.
Так aкак 'dynamic'в этот момент 'dynamic'авторизуется в консоли.
Ну, это то, что произошло бы, если бы JavaScript имел динамическую область видимости .

Однако он не имеет динамической области видимости. Это скорее лексическая область видимости , также известная как статическая область видимости .

В этой системе видимости, чтобы разрешить имя внутри функции, сначала выполняется поиск в локальном окружении функции, а затем в ее лексическом окружении .

Лексическое окружение функции fпросто относится к окружению , содержащему определение этой функции в исходном коде.
Другими словами, лексическое окружение данной функции основано на исходном коде программы, где функция определена. Вот почему мы называем это «лексической» средой, т.е. средой, основанной на исходном коде .

Чтобы понять, что подразумевается под определением функции , обратитесь к Основам функций JavaScript .
Итак, как именно это основано на исходном коде? Типа что под этим подразумевается?

Что ж, компилятор JavaScript читает исходный код программы и определяет среду, доступную для данной функции, на основе ее определения при ее компиляции.

Например, если функция fопределена в глобальной области видимости, ее лексическое окружение (определяемое при компиляции функции) является просто глобальным окружением.

Все множество окружений, окружающих функцию, вместе называются ее лексическим окружением.

Лексическое окружение функции может содержать несколько окружений.
Лексическое окружение определяется один раз и затем фиксируется на весь курс программы. Вот почему JavaScript называется языком со статической областью видимости — места, где заданные имена (переменных и функций) доступны в программе, являются статическими (т. е. не изменяются) и управляются исходным кодом.

Время понять все это с точки зрения реального примера.

Давайте еще раз рассмотрим фрагмент кода, показанный выше:

var a = 'static';

function f1() {
console.log(a);
}

function f2() {
var a = 'dynamic';
f1();
}

f2();
Здесь функция f1определена в глобальной области видимости, а ее лексическое окружение — это все глобальное окружение. То же самое касается функции f2().

Теперь, когда f2()вызывается в строке 12, сначала aсоздается и инициализируется локальная переменная, 'dynamic'а затем f1()вызывается. Внутри встречается f1()утверждение . console.log(a)На этом этапе имя aдолжно быть разрешено.

Вот как идет разрешение.

Сначала локальная область видимости f1ищется по имени a. Проще говоря, поскольку эта локальная среда пуста, такое имя не найдено. Следовательно, поиск переходит в лексическое окружение f1.
Поиск в лексическом окружении также идет упорядоченно. То есть сначала выполняется поиск в первой вмещающей среде функции, затем во внешней вмещающей области и так далее, пока в конце концов не будет достигнута глобальная среда, которая не имеет дополнительной вмещающей среды.
Окружающее лексическое окружение f1представляет собой просто глобальную область видимости, поэтому здесь выполняется поиск имени a. Поскольку совпадение найдено, привязанное к значению 20, имя ain console.log(a)разрешается со значением 20.
Именно так работает разрешение имен в JavaScript, Python, PHP и во всех языках со статической областью видимости.

Если вы запутались во всех этих определениях, давайте быстро подытожим то, что мы уже узнали в этом разделе.

Лексические средства, относящиеся к исходному коду или просто основанные на исходном коде. Лексическое окружение функции просто относится к окружению, содержащему определение функции. Он называется лексическим, потому что он основан на исходном коде и остается неизменным на протяжении всего выполнения программы.

Когда имя xупоминается в функции f, оно сначала ищется в локальном окружении, fа затем в его лексическом окружении.

Атрибут [[Scopes]]в Chrome
В наши дни браузерные консоли предоставляют довольно много внутренних атрибутов данных объектов для лучшей проверки. Google Chrome, в частности, предоставляет очень гибкую консоль.

Согласно спецификации ECMAScript , каждая функция содержит внутренний атрибут [[Environment]], который просто содержит лексическое окружение функции.

Самое приятное то, что этот атрибут является одним из атрибутов, предоставляемых консолью в Chrome. Однако на момент написания этой статьи его название было немного другим — оно называлось [[Scopes]].

Это означает, что мы могли фактически проверить лексическое окружение любой данной функции fв Chrome, проверив ее [[Scopes]]атрибут.

Рассмотрим тот же код, определенный выше. Обратите внимание, что мы пока не вызываем f2(), так как последний оператор закомментирован. Мы назовем его позже, как только закончим базовую проверку:

var a = 'static';

function f1() {
console.log(a);
}

function f2() {
var a = 'dynamic';
f1();
}

// f2();
Давайте проверим лексическое окружение f1. Вот как это сделать.

Сначала зарегистрируйте функцию, используя console.dir(), предоставив ссылку на функцию.
Затем щелкните значок курсора рядом с функцией, чтобы развернуть все ее свойства.
Здесь обратите внимание на [[Scope]]атрибут. Это массив, и его также можно расширить, чтобы увидеть содержимое массива.
Давайте добавим console.dir()оператор в наш код для проверки f1:

var a = 'static';

function f1() {
console.log(a);
}

function f2() {
var a = 'dynamic';
f1();
}

// f2();
console.dir(f1);
Для приведенного выше кода вот полностью расширенный вывод консоли:

Сначала функция f1разворачивается, чтобы увидеть ее свойства и внутренние атрибуты. Здесь [[Scopes]]атрибут расширен для просмотра лексического окружения f1.

В данном случае это массив только с одним объектом, указывающим на глобальную среду. Наконец, мы расширяем этот элемент [[Scopes]]. Затем следует большой список свойств, из которых мы смогли отобразить только первые пять.

Видите имя aздесь? Это глобальная переменная a. Это то, что используется для разрешения имени a, f1когда оно вызывается изнутри f2, в приведенном выше коде.

Давайте рассмотрим, что происходит, когда aвстречается в приведенной f1выше функции.

Локальное окружение f1ищется по имени a. Здесь ничего не находится, также поиск переходит в лексическое окружение f1.
В лексическом окружении, представленном через [[Scopes]], имя aищется в первом окружении, охватывающем f1. В этом случае эта среда просто оказывается глобальной средой.
Точно так же aищется в глобальной среде. Когда найдено совпадение, привязанное к значению 'static', aвход f1разрешается с помощью 'static'.
Простой?

Функции в одной области действия имеют одинаковое лексическое окружение.
Следует иметь в виду, что все функции в одной и той же области видимости указывают на одно и то же лексическое окружение. Это пустяковая деталь, которую в любом случае нужно было соблюсти.

Это означает, что в приведенном выше коде [[Scopes]]of f2будет таким же, как и [[Scopes]]of f1, потому что они оба находятся в глобальной области. Они будут ссылаться на один и тот же объект внутренней среды, хранящийся в памяти.

Хорошо, идем дальше, давайте внесем одно простое изменение в приведенный выше код, а затем пересмотрим его. Мы инкапсулируем все это внутри IIFE:

(function() {
var a = 'static';

function f1() {
console.log(a);
}

function f2() {
var a = 'dynamic';
f1();
}

// f2();
console.dir(f1);
})();
Теперь давайте выполним этот код. Вот что показывает нам консоль:

Атрибут [[Scopes]]( f1и f2) содержит две записи. Первый предназначен для первой среды, заключающей в себе определение, f1т. е. локальной среды IIFE, а второй — для второй среды, включающей f1, т. е., глобальную среду.

Вы можете подумать: почему этого нет f2в первой записи [[Scopes]]выше? Причина f2не в том, что из-за оптимизации, сделанной движком V8 (компилятор Chrome JavaScript). В этом случае движок видит, что f2это не требуется ни одной из функций ( f1и f2) внутри IIFE, а также не хранится в лексическом окружении этих функций.
Как и раньше, давайте посмотрим, что происходит, когда имя aвстречается внутри функции f1, в момент ее вызова:

Локальное окружение f1ищется по имени a. Здесь ничего не находится, также поиск переходит в лексическое окружение f1.
В лексическом окружении, представленном через [[Scopes]], имя aищется в первом окружении, включающем f1, т.е. в локальном окружении IIFE.
Здесь действительно aнаходится со значением 'static', аналогично ain f1разрешается со значением 'static'.
Легко, не так ли?

[[Scopes]]В этой главе мы рассмотрим другие примеры использования инспекции . А пока давайте углубимся в то, как работают замыкания.

Другие примеры
Давайте рассмотрим очень простой пример, расширяющий наш предыдущий фрагмент кода:

var a = 'easy';

(function() {
var b = 'easy';

function f1() {
console.log(a, b);
}

function f2() {
var a = 'difficult';
var b = 'difficult';
f1();
}

f2();
})();
Как и раньше, попытайтесь осмыслить вывод этого кода, прежде чем читать тест дальше.

Посмотреть результат↓
Хорошо, давайте посмотрим, как выполняется приведенный выше код.

Создается глобальная переменная a, которой присваивается значение 'easy', после чего создается и вызывается IIFE.
Для этого IIFE создается локальная среда. Здесь создается локальная переменная b, инициализированная значением 'easy'. Далее создаются две функции f1и .f2
На этом этапе происходит много вещей, подробно описанных в главе « Основы функций JavaScript» . Один из них — сохранить лексическое окружение функции внутри [[Environment]]внутреннего атрибута функции. Обратите внимание, что это происходит до фактического вызова функций.
Когда все это сделано, выполнение переходит к строке 16, где f2()вызывается.
Локальная среда создается для f2. Здесь определены две локальные переменные aи bобе содержат значение 'difficult'.
Далее f1()вызывается.
Локальная среда создается для f1. Выполнение переходит к оператору console.log(a, b)в строке 7. Теперь, прежде чем этот оператор может быть обработан, имена aи bдолжны быть разрешены.
Сначала решим a:
f1Ищется локальное окружение a. Совпадение не найдено, поэтому поиск переходит в лексическое окружение.
В лексическом окружении ищется первое объемлющее окружение f1, т. е. локальное окружение IIFE b.
Ничего не находится и здесь, поиск также переходит во вторую объемлющую среду (внутри лексической среды f1), т.е. в глобальную среду.
Поскольку здесь a = 'easy'найдено совпадение, имя ain разрешается со значением .console.log(a, b)'easy'
Теперь решим b:
f1Ищется локальное окружение b. Совпадение не найдено, поэтому поиск переходит в лексическое окружение.
В лексическом окружении ищется первое объемлющее окружение f1, т. е. локальное окружение IIFE b.
Поскольку здесь b = 'easy'найдено совпадение, имя bin разрешается со значением .console.log(a, b)'easy'
В этот момент разрешаются имена aи , поэтому инструкция выполняется, завершая выполнение , выполнение и, в конечном счете, выполнение всей программы.bconsole.log(a, b)f1f2
Простой?

Сохранение локальных окружений функций
Честно говоря, на данный момент мы знаем пару вещей, связанных с тем, как замыкание работает внутри. В частности, мы знаем, что такое лексические среды; что такое свободные переменные, как работает разрешение имен внутри функций.

Но один вопрос остается без ответа — «как получается, что JavaScript может удерживать локальное окружение функции после ее выхода» .

В этом разделе мы постараемся ответить на этот вопрос. Замыкания определенно утомительны для объяснения, но они стоят всех усилий.

Взгляните на код ниже:

function f1() {
var a = 'difficult';

return function() {
console.log(a);
};
}

var a = 'easy';
var f2 = f1();

f2();
Попытайтесь рассуждать о том, какой результат будет получен фрагментом кода и почему?

Посмотреть результат↓
Когда приведенный выше код выполняется, вот что происходит:

Создается функция f1, за которой следует глобальная переменная , которой aприсваивается значение 'easy'.
f1()Далее вызывается функция .
Для функции создается локальная среда f1. Здесь определена переменная a, содержащая значение 'difficult'. Затем создается анонимная функция, лексическое окружение которой включает это локальное окружение (из f1), и, наконец, эта функция возвращается .
На этом этапе, поскольку функция возвращает значение, f1что означает, что она завершила выполнение, движок JavaScript должен удалить свою локальную среду. Теперь перед удалением выполняется быстрый поиск, чтобы выяснить, существуют ли какие-либо ссылки на эту среду. Поскольку вне локальной области действия функции f1действительно существует ссылка — в [[Environment]]атрибуте возвращаемой функции — среда сохраняется в памяти . Однако другие необходимые процедуры выполняются как обычно, например, для очистки кадра стека вызовов для f1.
Вызов f1()завершается, и возвращаемое значение, которое является анонимной функцией, присваивается глобальной переменной f2. Потом f2()называется.
Локальная среда создается для f2. Выполнение переходит к строке 5, после чего имя ain console.log(a)должно быть разрешено.
Вот как это решается:
Локальное окружение f1ищется по имени a. Здесь ничего не находится, поиск также переходит в лексическую среду.
В пределах лексического окружения проверяется первое вмещающее окружение f1, то есть локальное окружение функции .f2a
Здесь, поскольку совпадение a = 'difficult'найдено, имя ain console.log(a)разрешается вниз со значением 'difficult'.
Простой?

Самое интересное, что здесь следует отметить, это то, что локальная среда f1НЕ удаляется даже при f1выходе (через returnключевое слово). Это связано с тем, что в возвращаемой анонимной функции существует ссылка на его локальную среду.

Движок проверяет, есть ли хотя бы одна ссылка на локальное окружение функции, выходящей за пределы функции. Если есть, локальная среда не подвергается сборке мусора .
В коде, показанном выше, вы можете подумать, что не существует ссылки на локальную среду f1вне функции, т. е. есть только одна ссылка на локальную среду, f1которая хранится в анонимной функции, которая сама является частью f1.

Хм..

Это правда, что анонимная функция, единственная вещь, которая ссылается на локальную среду f1, является частью f1. Но вы забыли одну важную вещь.

Анонимная функция возвращается . f1Это означает, что в конечном итоге он будет доступен снаружи f1, в регионе, где f1вызывается (в приведенном выше коде он вызывается в глобальной области видимости в строке 10).

Итак, чтобы [[Environment]]атрибут анонимной функции оставался нетронутым, локальное окружение f1должно храниться в памяти.

Если бы мы переписали ключевое слово f1так, чтобы returnоно было удалено, его локальная среда больше не удерживалась бы после его выхода.

function f1() {
var a = 'difficult';

(function() {
console.log(a);
});
}

var a = 'easy';
var f2 = f1();

f2();
Вы помните, почему нам нужно заключить приведенную выше функцию в пару круглых скобок ( ()). Если нет, вы можете узнать больше об этом в разделе Функции JavaScript — Основы .
Почему? Просто потому, что локальная среда больше не нужна вне функции.

Пока f1выполняется и его локальное окружение находится в памяти, [[Environment]]атрибут анонимной функции внутри него содержит ссылку на f1локальное окружение.

Но при f1выходе аноним уже не нужен, так же он убирается сборщиком мусора и вместе с ним привязанная ссылка на локальное окружение f1. С исчезновением этой ссылки на f1локальную среду эта среда также подвергается сборке мусора.

Супер фундаментальная, но очень эффективная идея!

Функции, возвращающие другие функции, возможно, являются одним из наиболее распространенных применений замыканий в программах на JavaScript. Весьма вероятно, что как только вы начнете создавать сложные программы, вы тоже будете их использовать.

Практическое применение
Давайте, наконец, посмотрим на некоторые практические приложения закрытия функций в JavaScript в реальном мире.

Шаблон проектирования модуля
Когда вы начнете создавать большие сложные программы с чертовски сложной логикой, вы скоро начнете терять след программы во время ее разработки.

У вас бывают такие моменты, как «что мне написать дальше?» , 'О, этой функции тоже нужен этот параметр!' , 'эта функция делает много вещей' , 'Я повторяю довольно много кода' . Вещи скоро станут менее управляемыми или полностью неуправляемыми.

Это произойдет наверняка. Это случается с каждым разработчиком, когда он начинает писать большую программу. Именно в этом могут помочь шаблоны проектирования, хотя и не во всем.

Шаблон проектирования дает нам подход к решению проблемы. В нем излагаются правила и общая структура, которой необходимо следовать при написании программы. О шаблонах проектирования в программировании можно рассказать так много, что им можно было бы посвятить целый курс.

На данный момент нас интересует только шаблон проектирования модуля , и это в рамках JavaScript.

В шаблоне проектирования модуля мы группируем код в то, что называется модулем, и экспортируем обратно объект с общедоступными свойствами и методами, которые имеют доступ к закрытым материалам, определенным внутри модуля.

Преимущество этого шаблона проектирования заключается в том, что мы можем консолидировать код в одном месте и, таким образом, лучше организовать наши кодовые базы, и в то же время иметь возможность более эффективно организовывать и поддерживать код в каждом модуле.

Вот как выглядит узор:

var moduleName = (function() {
var privateVar;
// more such private variables

function privateFunction() {}
// more such private functions

return {
publicProp: value,
// more such public properties

      publicMethod: function() {},
      // more such public methods

}
})();
Например, предположим, что мы хотим создать объект с многочисленными методами для обработки матричных операций, таких как сложение, вычитание, умножение, поворот, добавление диагоналей и т. д. и т. п.

Создание этой библиотеки возможно с использованием литералов объектов, но не без некоторых проблем.

Давайте просто создадим быструю фиктивную программу, чтобы визуализировать все намного лучше:

// some variable defined here that are accessible
// by the entire code below
/_ ... _/

var matrix = {
// create r x c matrix
create: function(r, c = r) { /_ ... _/ },

// return a + b
sum: function(a, b) { /_ ... _/ },

// return a - b
diff: function(a, b) { /_ ... _/ },

// return a x b
product: function(a, b) { /_ ... _/ },

// return the sum of the elements in the diagonal,
// starting from the top-left corner of the a
sumDiagonal: function(a) { /_ ... _/ },

// more methods follow
/_ ... _/
}
Выполнив приведенную выше библиотеку, мы могли бы использовать такие вещи, как matrix.sum()сложение двух матриц вместе, matrix.product()умножение двух матриц вместе и так далее. Теперь давайте проанализируем проблемы в этом подходе.

Прежде всего, если требуются некоторые переменные, доступные во всем модуле matrix, они должны быть определены либо в глобальной области видимости, либо как часть объекта matrix.

В первом случае мы бы излишне переполняли глобальную область действия идентификаторами, при этом создавая риск конфликтов имен с другими сценариями, используемыми на веб-странице.

С другой стороны, в последнем случае нам пришлось бы создавать пространство имен идентификатора каждый раз, когда нам нужно получить к нему доступ, потому что теперь он является свойством matrix.

Эта проблема с пространством имен возникает и при работе внутри методов. Например, предположим, что метод matrixдолжен использовать другой метод, определенный для него. При буквальном подходе, описанном выше, нам пришлось бы использовать пространство имен метода каждый раз, когда мы его используем.

Все эти проблемы, объединенные вместе, могут очень скоро разочаровать.

Лучшим вариантом является использование шаблона проектирования модуля.

Давайте быстро перепишем приведенный выше код, используя шаблон модуля:

var matrix = (function() {
// variables that ought to be accessible by the
// entire code below are defined here
/_ ... _/

// create r x c matrix
function create(r, c = r) { /_ ... _/ }

// return a + b
function sum(a, b) { /_ ... _/ }

// return a - b
function diff(a, b) { /_ ... _/ }

// return a x b
function product(a, b) { /_ ... _/ }

// return the sum of the elements in the diagonal,
// starting from the top-left corner of the a
function sumDiagonal(a) { /_ ... _/ }

return {
create: create,
sum: sum,
diff: diff,
product: product,
sumDiagonal: sumDiagonal,

      // more methods follow
      /* ... */

}
})();
Как вы видите, все методы возвращаемого объекта определены как локальные функции IIFE. matrixЭто означает, что благодаря замыканиям они могут ссылаться друг на друга без использования пространства имен .

Это большое достижение. Во-вторых, глобальная область видимости аккуратна и чиста, в ней нет ненужных имен.

В целом модульный паттерн проектирования в нашем случае является беспроигрышным.

И еще раз, замыкание функций позволяет этому шаблону проектирования работать без каких-либо проблем в JavaScript. Не будет ошибкой сказать, что модульный паттерн является одним из наиболее распространенных применений замыканий в JavaScript.

Функции высшего порядка
Функция, которая принимает функцию в качестве аргумента и/или возвращает функцию, называется функцией высшего порядка .

На данный момент нас интересует последняя часть этого определения, то есть функция, возвращающая функцию.

В программе JavaScript будет много случаев, когда вам понадобится функция более высокого порядка. Давайте посмотрим на один такой пример.

Скажем, мы хотим создать функцию, которая позволяет нам получить n -й элемент из заданной арифметической последовательности. Например, если бы мы моделировали арифметическую последовательность всех положительных четных целых чисел, начиная с 2, функция могла бы выглядеть примерно так:

function evens(n) {
return 2 + n \* 2;
}

console.log(evens(0), evens(1));
2 4
Мы предоставляем значение для n, начиная с 0, к которому функция возвращает n -й элемент в последовательности. В нашем случае, поскольку последовательность начинается с 2, evens(0)возвращается 2, evens(1)возвращается 4и так далее.

2Если бы нужно было смоделировать только последовательность всех четных целых чисел, начинающихся с , нашей evens()функции было бы достаточно. Однако, если бы мы разрешили настраивать и арифметическую последовательность, нам пришлось бы немного изменить функцию.

Теперь функция будет выглядеть примерно так:

function elementFromSequence(n, a, d) {
return a + n \* d;
}
Смоделируем последовательность всех нечетных положительных целых чисел, начиная 1с этой функции, и получим значение первого, второго и сотого элемента из этой последовательности:

function elementFromSequence(n, a, d) {
return a + n \* d;
}

console.log(elementFromSequence(0, 1, 2), elementFromSequence(1, 1, 2), elementFromSequence(100, 1, 2));
1 3 201
Как вы можете ясно видеть, в этом подходе есть один разочаровывающий момент. Если мы моделируем одну и ту же последовательность в куче вызовов, мы должны упоминать аргументы для aи снова и снова .d

Посмотрите, как мы должны многократно передавать последние два аргумента 1и 2каждый раз при вызове elementFromSequence().

Чтобы решить эту проблему, мы могли бы использовать очень простую концепцию — замыкание функций.

Хитрость заключается в том, чтобы создать функцию, которая принимает значения для aи dодин раз, а затем возвращает функцию, которая принимает только один аргумент n. Эта возвращаемая функция запоминает переменные своего лексического окружения aи d, поэтому ее можно использовать для проверки любого n -го элемента заданной последовательности.

Ниже показан код:

function defineSequence(a, d) {
return function(n) {
return a + n \* d;
}
}

var evens = defineSequence(2, 2);
console.log(evens(0), evens(1));

var odds = defineSequence(1, 2);
console.log(odds(0), odds(1), odds(100));
2 4
1 3 201
Самым большим преимуществом этого подхода является то, что мы можем создать функцию проверки для любой арифметической последовательности при вызове defineSequence(), а затем просто передать один единственный аргумент (возвращенной) функции проверки.

Это дает нам большую гибкость по сравнению со старым, монотонным и прямым подходом передачи аргументов для aи dпрямо в то время, когда проверяется n -й элемент данной последовательности.
