В этой статье мы подробно рассмотрим все основные понятия функций JS, обратных вызовов, областей видимости, замыканий, которые помогут вам:

понимать различные типы объявлений функций.
лучше использовать функции.
понять, как разные области видимости и цепочки областей работают в JS.
Узнайте о замыканиях и о том, как их использовать.
Мы поймем все эти концепции на примерах, а также поймем их реализацию. Начнем обсуждение с функций Javascript.

Функции: Функция позволяет нам объявить и упаковать кучу кода в блок, чтобы мы могли использовать (и повторно использовать) блок кода в наших программах. Иногда они принимают некоторые значения в качестве «параметров» для выполнения операции и возвращают некоторое значение в результате операции.

Пример:



    function add(a, b) {
      
    // a and b are the parameters of this
    // function code to do the operation
    return a + b; // return statement
    }
      
    // Invoking the function and 2, 3
    // are arguments here
    console.log(add(2, 3));
Вывод: 

5
Гражданин первого класса: если какой-либо язык программирования имеет возможность обрабатывать функции как значения, передавать их в качестве аргументов и возвращать функцию из другой функции, то говорят, что язык программирования имеет функции первого класса, и функции называются первоклассными . Класс Citizens на этом языке программирования. Функции будут считаться первоклассными гражданами в JavaScript, если функции:

хранить функции в переменной.
передать функцию в качестве аргумента другой функции.
вернуть функцию из другой функции.
Функциональные выражения: когда функция хранится внутри переменной, она называется функциональным выражением. Это может быть именным или анонимным. Если функция не имеет имени и хранится в переменной, то она будет известна как выражение анонимной функции . В противном случае это было бы известно как именованное функциональное выражение. Дополнительные сведения см. в статье о выражении функции JavaScript .

Пример:


<script type="text/javascript" charset="utf-8">
    // Anonymous function expression
    const add = function (a, b){
    return a + b;
    }
      
    // Named function expression
    const subtractResult = function subtract(a, b){
    return a - b;
    }
      
    console.log(add(3, 2)); // 5
    console.log(subtractResult(3, 2)); // 1
</script>
Вывод:

5
1
Обратные вызовы: хранение функции в переменной позволяет очень легко передать функцию другой функции в качестве аргумента. Функция, которая принимает другие функции в качестве аргументов или возвращает функцию, называется функцией высшего порядка . Функция, которая передается в качестве аргумента в другую функцию, называется функцией обратного вызова . Проще говоря, если мы хотим выполнить функцию сразу после возврата какой-либо другой функции, то можно использовать обратные вызовы . Пожалуйста, обратитесь к JavaScript | Статья об обратных вызовах для более подробной информации .

Пример:


    function showLength(name, callback) {
      callback(name);
    }
      
    // function expression `nameLength`
    const nameLength = function (name) {
      console.log(`Given Name ${name} which 
      is ${name.length} chars long`);
    };
      
    // Passing `nameLength` as a callback function
    showLength("GeeksforGeek", nameLength); 
      
Вывод:

Имя GeeksforGeek длиной 12 символов.
Шаблонный литерал в ES6 предоставляет новые функции для создания строки, которая дает больший контроль над динамическими строками. Традиционно String создается с использованием одинарных (') или двойных (") кавычек. Литерал шаблона создается с помощью символа обратной кавычки (`), который позволяет объявлять встроенные выражения. Как правило, мы используем функцию обратного вызова в методах массива — forEach(), map(), filter(), reduce().


Стрелочная функция: это выражение или синтаксис, который упрощен, а также более компактная версия обычного или нормального функционального выражения или синтаксиса. Ее проще реализовать, чем обычную функцию, но она имеет некоторые ограничения. Пожалуйста, обратитесь к Стрелочной функции ES6 , чтобы узнать больше о стрелочных функциях .

Синтаксис:

Для одного аргумента:
пусть имя_функции = аргумент1 => выражение
Для нескольких аргументов:
пусть имя_функции = (аргумент1, аргумент2, ...) => выражение
Пример:


<script>
        
    //  Normal function for multiplication
    // of two numbers
    function multiply(a, b) {
        return a * b;
    }
    console.log(multiply(3, 5));
</script>
Вывод:

15
Область действия: это область программы, в которой можно получить доступ к переменной. Другими словами, область видимости определяет доступность/видимость переменной. Поскольку JavaScript выглядит как язык C-семейства, вполне очевидно, что область видимости в JavaScript похожа на ту, что используется в большинстве внутренних языков программирования, таких как C, C++ или Java. Пожалуйста, обратитесь к разделу Что такое переменная область видимости в JavaScript? статью для более подробной информации. В JavaScript есть 3 вида областей видимости:

Глобальная область : переменные, объявленные вне всех функций, называются глобальными переменными и находятся в глобальной области. Глобальные переменные доступны в любом месте программы.
Область действия функции : переменные, объявленные внутри функции, называются локальными переменными и находятся в области действия функции. Локальные переменные доступны в любом месте внутри функции.  
Область блока: переменная, которая объявлена ​​внутри определенного блока и не может быть доступна за пределами этого блока. Чтобы получить доступ к переменным этого конкретного блока, нам нужно создать для него объект.
Код внутри функции имеет доступ к:

аргументы функции.
локальные переменные, объявленные внутри функции.
переменные, объявленные в области действия родительской функции.
глобальные переменные.

    const name = "GeeksforGeeks";
      
    function introduceMyself(greet) {
    const audience = "Everyone";
    function introduce() {
      console.log(`${greet} ${audience}, This is ${name} Learning!`);
    }
    introduce();
    }
      
    introduceMyself("Hello");
Вывод:

Привет всем, это GeeksforGeeks Learning!
Область действия блока: Это говорит нам о том, что любая переменная, объявленная внутри блока ({}), может быть доступна только внутри этого блока.  

Теперь, что такое блок ? блок {} используется для группировки операторов JavaScript в 1 группу, чтобы его можно было использовать в любом месте программы, где ожидается запись только 1 оператора.

Область действия блока относится только к переменным, объявленным с помощью `let` и `const`. Переменные, объявленные с помощью `var`, не имеют блочной области видимости.

Пример:

{
    пусть а = 3;
    вар б = 2;
}

console.log(а); //Uncaught ReferenceError: a не определено
console.log(б); // 2 как переменные, объявленные с помощью `var`  
функционально и глобально с областью действия НЕ с блочной областью действия
Цепочка областей действия: Всякий раз, когда наш код пытается получить доступ к переменной во время вызова функции, он начинает поиск с локальных переменных. И если переменная не найдена, она будет продолжать поиск в своей внешней области или области действия родительских функций, пока не достигнет глобальной области и не завершит поиск переменной там. Поиск любой переменной происходит по цепочке областей видимости или в разных областях видимости, пока мы не получим переменную. Если переменная не найдена и в глобальной области видимости, возникает ошибка ссылки.  

Пример:


    const name = "GeeksforGeeks";
      
    function introduceMyself(greet) {
      const audience = "Everyone";
      
      function introduce() {
        console.log(`${greet} ${audience}, This is ${name} Learning`);
      }
      
      introduce();
    }
      
    introduceMyself("Hello");
Вывод:

Привет всем, это GeeksforGeeks Learning
В приведенном выше примере, когда код пытается получить доступ к переменной `name` внутри функции `introduce()`, он не получает там переменную и пытается выполнить поиск в области действия своей родительской функции (`introduceMyself()`). И поскольку его там не было, он, наконец, поднялся до глобальной области видимости для доступа к переменной и получил значение переменной `name`.

Затенение переменной: если мы объявим переменную с тем же именем, что и у другой переменной в цепочке областей видимости, переменная с локальной областью видимости будет скрывать переменную во внешней области видимости. Это известно как затенение переменных . Дополнительные сведения см . в статье « Затенение переменных в JavaScript ».

Пример 1:


    let name = "Abhijit";
    var sector = "Government";
      
    {
      let name = "Souvik";
        
      // as `var` is NOT block scoped(globally s
      // coped here), it'll update the value
      var sector = "Private"; 
      console.log(name); //Souvik
      console.log(sector); //Private
    }
      
    console.log(name); //Abhijit
    console.log(sector); //Private
Вывод:

Сувик
Частный
Абхиджит
Частный
Пример 2:


    let name = "Abhijit";
    var sector = "Government";
      
    function showDetails() {
      let name = "Souvik";
      
      // `var` is functionally scoped here,
      // so it'll create new reference with 
      // the given value for organization
      var sector = "Private";
      console.log(name); // Souvik
      console.log(sector); // Private
    }
      
    showDetails();
    console.log(name); // Abhijit
    console.log(sector); // Government
Объяснение : В примере 1 переменная `name` затеняет переменную с тем же именем во внешней области внутри блока, поскольку мы использовали `let` для объявления переменной. Но переменная `sector` также обновляет значение в то же время, когда мы использовали `var` для ее объявления. А поскольку мы знаем, что `var` имеет функциональную и глобальную область видимости, объявление с тем же именем (`sector`) внутри блока будет обновлять значение по той же ссылке. Принимая во внимание, что в примере 2 переменная `sector` внутри функции находится в области действия функции и создаст новую ссылку, которая просто затенит переменную с тем же именем, объявленную снаружи.

Вывод:

Сувик
Частный
Абхиджит
Правительство
Закрытие: это способность функции запоминать переменные и функции, объявленные в ее внешней области.

MDN определяет закрытие как «комбинацию функции, связанной вместе со ссылками на ее окружающее состояние или лексическое окружение » .

Теперь, если вы думаете, что такое лексическое окружение ? локальная среда функции вместе со средой родительской функции образует лексическую среду. Пожалуйста, обратитесь к статье « Замыкание в JavaScript », чтобы понять эту концепцию.

Пример:


    function closureDemo(){
        const  a = 3;
          
        return function (){
              console.log(a);  
        }
    }
      
    // Returns the definition of inner function
    const innerFunction = closureDemo();
    innerFunction(); // 3
Выход будет 3.

В приведенном выше примере, когда вызывается функция closureDemo(), она возвращает внутреннюю функцию вместе с ее лексической областью видимости. Затем, когда мы попытаемся выполнить возвращенную функцию, она попытается зарегистрировать значение `a` и получить значение из ссылки на свою лексическую область. Это называется закрытием . Даже после выполнения внешней функции возвращаемая функция по-прежнему содержит ссылку на лексическую область видимости.

Преимущества:

карри
Мемоизация
Шаблон проектирования модуля
Недостатки:

Чрезмерное потребление памяти может привести к утечке памяти, поскольку самая внутренняя функция содержит ссылку на лексическую область видимости, а переменные, объявленные в ее лексической области видимости, не будут удалены сборщиком мусора даже после выполнения внешней функции.
Немедленно вызываемое функциональное выражение (IIFE): немедленно вызываемое функциональное выражение или IIFE — это функция, которая вызывается сразу после ее определения. Пожалуйста, обратитесь к JavaScript | Статья о немедленно вызываемых функциональных выражениях (IIFE) для получения дополнительной информации.

Синтаксис:

(задача функции(){
    console.log("В настоящее время пишу блог о функциях JS");
})();
По сути, мы заключаем функцию в круглые скобки, а затем добавляем пару круглых скобок в конце, чтобы вызвать ее.

Передача аргументов в IIFE: Мы также можем передавать аргументы в IIFE. Вторая пара скобок может использоваться не только для немедленного вызова функции, но и для передачи любых аргументов в IIFE. 
(функция showName(имя){
   console.log(`Имя: ${имя}`); // Имя Сувик
})("Сувик");
IIFE и частная область: если мы можем использовать IIFE вместе с закрытием, мы можем создать частную область и защитить некоторые переменные от доступа извне. Та же идея используется в шаблонах проектирования модулей для сохранения конфиденциальности переменных.  
Пример:


    // Module pattern
    let greet = (function () {
      const name = "GeekforGeeks"; // Private variable
      
      return {
        introduce: function () {
          console.log(`Hello, This is ${name} Learning!`);
        },
      };
    })();
      
    console.log(greet.name); //undefined
      
    // Hello, This is GeekforGeeks Learning!
    greet.introduce(); 
IIFE помогает предотвратить доступ к переменной `name` здесь. И метод `introduce()` возвращаемого объекта сохраняет область действия своей родительской функции (из-за закрытия), мы получили открытый интерфейс для взаимодействия с `name`.

Вывод:

неопределенный
Здравствуйте, это обучение GeekforGeeks!