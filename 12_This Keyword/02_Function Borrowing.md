Заимствование функций в JavaScript
Когда мы создаем объекты JavaScript, мы обычно связываем их с определенным поведением. Рассмотрим приведенный ниже пример:

Мы создали класс Dog с тремя свойствами и двумя методами, одним из которых является tellUsAboutYourSelf(). Мы также создали новый экземпляр Dog, который сохраняется в переменной fido. Довольно просто. Теперь давайте создадим еще один класс и создадим экземпляр нового экземпляра:

Мы создали объект Cat с теми же свойствами, что и наш объект Dog, но наш экземпляр Cat, сохраненный в переменной sparkles, не может рассказать нам о себе. Мы могли бы реорганизовать наш код так, чтобы класс Cat наследовался от класса Dog, но в этом сценарии все наши объекты Cat могли бы «гавкать», что кажется неуместным или необходимым. Введите: функция заимствования.

Как это работает?
Заимствование функций позволяет нам использовать методы одного объекта для другого объекта без необходимости создавать копию этого метода и поддерживать его в двух разных местах. Это достигается за счет использования .call(), .apply(), или .bind(), которые существуют для явной установки thisметода, который мы заимствуем.

Учитывая объекты, которые мы создали выше, взгляните на заимствование функций в действии:

fido.tellUsAboutYourSelf.call(блестки)
//=>'Меня зовут Спарклз. Я сиамец, мне 5 лет».
fido.tellUsAboutYourSelf.apply(блестки)
//=>'Меня зовут Спарклз. Я сиамец, мне 5 лет».
const descriptionSparkles = fido.tellUsAboutYourSelf.bind(блестки)
описатьИскры()
//=>'Меня зовут Спарклз. Я сиамец, мне 5 лет».
Каждый из этих примеров работает this, потому что при ссылке внутри метода он ссылается на объект, получивший вызов метода. .call(), .apply(), и .bind()работают, позволяя нам изменять объект, на который thisссылается .tellUsAboutYourSelf()метод. Принимая во внимание , что .call()и .apply()немедленно выполнить вызов функции, .bind()сохраняет функцию на потом. После того, как мы сохранили заимствованную функцию в переменную describeSparkles, мы можем вызвать ее describeSparklesчерез сотню строк и увидеть тот же результат.

В чем смысл?
Основное преимущество заимствования функций заключается в том, что оно позволяет отказаться от наследования. У вас нет причин заставлять класс наследовать от другого, если вы делаете это только для того, чтобы предоставить экземплярам дочернего класса доступ к одному методу. И, как я упоминал выше, заимствование функций избавляет вас от необходимости писать одну и ту же функцию дважды и поддерживать ее в двух местах, что снижает риск ошибок.

Наиболее важное практическое применение заимствования функций относится к нативным методам и, в частности, к Array.prototype.slice. Существует несколько спископодобных структур данных, которые не являются массивами, и полезно иметь возможность обращаться с ними как с массивами и работать с ними как с таковыми. Одной из наиболее распространенных структур данных, подобных спискам, которая не является массивом, является arguments. Объект arguments представляет все параметры, переданные данной (не стрелочной) функции.

Возьмем, к примеру, следующую функцию:

В приведенном выше примере findOэто функция с переменным числом аргументов, что означает, что она принимает переменное количество аргументов. Мы передали ему четыре строки, и мы хотели бы увидеть, какая из этих строк содержит букву «о». Объект argumentsсодержит эти четыре строки, но мы не можем просто вызывать их .filter(), argumentsпотому что это не массив. Однако мы можем преобразовать его в массив, позаимствовав .sliceметод из Array.prototype и установив this его равным argumentsобъекту. После преобразования в массив у нас есть доступ ко всем встроенным методам Array.
