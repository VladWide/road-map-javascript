Обнаружение утечек памяти с помощью Chrome DevTools

Когда выделенная память не возвращается операционной системе или пулу памяти, мы называем это утечкой памяти . В этом случае память не используется никаким приложением и занята без необходимости. Это приводит к низкой производительности, высокой задержке и частым сбоям.

Понимание утечек памяти
Если вы знакомы с низкоуровневыми языками, такими как C, вы должны были использовать malloc()и free(). Напротив, JavaScript автоматически выделяет память при создании объектов и освобождает ее, когда они больше не используются.

Что ж, поскольку она управляется автоматически, у нас, разработчиков, всегда создается ложное впечатление, что нам не нужно беспокоиться об управлении памятью в браузерах. Если сайт использует все больше и больше памяти, значит ее никто не собирает и есть утечка памяти.

Сборщики мусора
Если бы сборщики мусора (GC) были идеальными, то утечки памяти не были бы проблемой. Проблема в том, что их алгоритмы недостаточно умны, чтобы обнаруживать утечки памяти; таким образом, требуется вмешательство человека.

Сборщики мусора выполняют процесс поиска памяти, которая больше не используется программой, и освобождают ее обратно в ОС для будущего перераспределения. Способ действенный, но все равно случаются утечки памяти. Этот метод не способен обнаруживать каждую утечку, например утечку ссылок.

Браузеры используют два конкретных алгоритма:

1. Разметить и подметать
   Во время маркировки и очистки сборщик мусора инициализирует все биты меток равными 0. Всякий раз, когда мы создаем объект, бит метки устанавливается в 1. Бит метки каждого достижимого объекта устанавливается в 1. Наконец, сборщик мусора собирает все объекты, биты метки которых установлены в 0.

2. Алгоритм подсчета ссылок
   В этом алгоритме алгоритм проверяет, не нужен ли объект больше. Алгоритмы подсчета ссылок являются самыми основными алгоритмами GC. Если на объект нет ссылок, указывающих на него, сборщик мусора собирает его.

Хотя эти алгоритмы доступны, они не идеальны, и поэтому нам нужны некоторые инструменты для обнаружения утечек памяти.

Почему происходит утечка памяти?
Многие вещи могут вызвать утечку памяти, и мы рассмотрим их одну за другой.

Случайные глобальные переменные
function getWork() {
this.work = «Я — утечка памяти»;
}
// Здесь this относится к объекту окна и, следовательно, эта переменная будет создана в окне.
получитьработу();
Поскольку глобальные переменные не собираются сборщиком мусора, если эта строка станет слишком большой, это может вызвать утечку памяти. Аналогичным примером случайных глобальных переменных может быть объявление переменных без использования ключевых слов letи var.

Отдельные узлы DOM
Отключение узлов DOM — серьезная проблема. Отсоединенные узлы все еще существуют в памяти из-за их глобальных ссылок.

узел var = document.createElement('a');
узел.id = 'id1';
document.body.appendChild (узел);
var main = {
Идентификатор: document.getElementById('id1')
}
function removeElement () {
document.body.removeChild (document.getElementById ('id1'));
}
// «Это» здесь относится к объекту окна, и, следовательно, эта переменная будет создана в окне.
удалитьЭлемент();
В приведенном выше примере removeChildфункция удалила узел DOM из дерева, но идентификатор ссылки в глобальном основном объекте все еще остается в памяти и не подвергается сборке мусора.

Закрытия
Замыкания сохраняют область видимости переменных внешней функции для внутренней функции даже вне области действия внешних функций.

function getScore(x) {
function score(y) {
return x + y;
}
обратная оценка;
}
// Здесь this относится к объекту окна и, следовательно, эта переменная будет создана в окне.
исходная переменная = getScore (2);
вар окончательный = начальный (3);
Функция scoreздесь, которая является внутренней функцией, имеет глобальную ссылку с именем initial. Эта исходная ссылка никогда не будет удалена сборщиком мусора.

Инструменты для выявления утечек памяти
Сравнения для моментального снимка
Случайные глобальные переменные Утечки памяти можно легко обнаружить с помощью профилирования. Давайте рассмотрим пример фрагмента кода, который вызовет утечку памяти из-за глобальной переменной.

var x = []
var bool = false;
функция роста(){
x.push(новый массив(100000).join('a'));
если (логическое значение) {
setTimeout (рост, 1000);
}
}
функция start(){
рост();
логический = истина;
}
функция стоп () {
логическое значение = ложь;
}
Чтобы проверить этот код, мы можем сделать снимки кучи, перейдя на панель профиля в инструментах разработчика.

Здесь желтый цвет объекта окна на самом деле изображает узлы, на которые есть прямые ссылки из кода JS . Нам нужно исправить код, чтобы избавиться от желтых маркеров .

Здесь можно сделать массив локальным внутри функции, чтобы сборщик мусора мог его собрать, или явно удалить глобальную переменную. Вы можете найти исправленный код как:

переменная бул = ложь;
функция роста(){
var x = [];
x.push(новый массив(100000).join('a'));

если (логическое значение) {
setTimeout (рост, 1000);
}
}
функция start(){
рост();
логический = истина;
}
функция стоп () {
логическое значение = ложь;
}
Профилировщик распределения
Временная шкала распределения — это еще один инструмент, который может помочь вам отследить утечки памяти в куче JS. Чтобы записать временную шкалу, перейдите на панель своего профиля и нажмите «Пуск» для того же кода, который был указан выше.
Когда мы нажимаем Startкнопку, как показано на изображении, и профилируем с помощью профилировщика распределения, мы видим, что он генерирует синие линии, как показано на изображении.

Представляют blue barsновое выделение памяти, которое может быть утечкой памяти . Вы можете углубиться в детали, увеличив масштаб любой из этих синих полос. Детали здесь представляют длинные строки, которые помещаются в массив и никогда не собираются мусором.

Заключение
Сборщики мусора необходимы, но недостаточны. Таким образом, для предотвращения утечек памяти требуется вмешательство человека с использованием правильных инструментов и знаний.

Если вам известны описанные выше общие шаблоны, в которых происходят утечки памяти, вы сможете быстро проверить их с помощью Chrome DevTools.

Если вам понравилась статья, пожалуйста, похлопайте в ладоши. Совет — ваши 50 хлопков сделают мой день лучше!

Хотите узнать больше обо мне? Пожалуйста, проверьте мой веб-сайт . Если вы хотите получать обновления, подписывайтесь на меня в Twitter и Medium . Если что-то непонятно или вы хотите на что-то указать, пожалуйста, прокомментируйте ниже.
