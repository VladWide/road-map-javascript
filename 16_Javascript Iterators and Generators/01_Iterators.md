Итераторы JavaScript
Что вы узнаете на этой странице?
Что такое итератор
Создание простого итератора
Предопределенные итераторы
Метод @@iterator\_

Итерация
Вступление
Итерация
Итерации

Что такое итератор?
На базовом уровне итератор — это объект JavaScript, предоставляющий итератору утилиты для заданной последовательности.

На техническом уровне:

Итератор — это объект JavaScript, реализующий протокол итератора .
Что такое протокол итератора?

Протокол итератора — это просто набор правил, которым должен подчиняться объект, чтобы его можно было назвать итератором.

В протоколе указано, что объект должен иметь next()метод . Этот метод должен возвращать объект со следующими двумя свойствами:

done- логическое значение, указывающее, достиг ли итератор своего последнего значения.
value- содержит следующее значение в заданной последовательности.
Теперь, прежде чем мы приведем живой пример итератора, сначала попытайтесь интуитивно понять эти имена свойств и методов.

Предположим, у вас есть объект-итератор iter. При обращении next()к нему должно быть получено следующее значение в последовательности, над которой он работает — при начальном вызове это будет первое значение в последовательности.

Затем вызов iter.next()во второй раз должен снова вернуть следующее значение в последовательности - при втором вызове это будет второе значение в последовательности. И так далее...

Это продолжается до тех пор, пока последовательность больше не содержит значений.

Обе эти идеи представлены итератором следующим образом:

Каждое следующее значение в последовательности сохраняется внутри valueсвойства объекта, возвращаемого next(). Тот факт, что мы достигли конца последовательности , сохраняется в doneсвойстве того же объекта.
Если doneэто trueозначает, что мы закончили - нет необходимости продолжать итерацию! Точно так же, если doneis false, это означает, что мы еще не закончили — нам еще нужно идти дальше!

Имея в виду это обсуждение, давайте рассмотрим простой итератор и более подробно разберемся, как он должен работать.

Простой итератор
Предположим, что у нас есть массив numsи задача перебора всех его элементов и их регистрации.

var nums = [1, 5, 16];
Теперь представьте, что у нас также есть объект-итератор iterдля перебора этого массива.

Принцип работы итератора демонстрируется следующим образом:

Вызов iter.next()в первый раз вернет объект, обертывающий первое значение в nums.

iter.next(); // {value: 1, done: false}
Свойство объекта valueбудет равно, 1а doneсвойство равно false, поскольку мы еще не закончили.

Вызов iter.next()во второй раз вернет объект, обертывающий второе значение в nums.

iter.next(); // {value: 5, done: false}
valueбудет равно 5и doneравно false, так как мы еще не закончили!

Вызов iter.next()в третий раз вернет объект, обертывающий третье (и последнее) значение в nums.

iter.next(); // {value: 16, done: false}
valueбудет равно 16и doneбудет равно false.

Теперь вы можете подумать, что почему не doneравно trueздесь.

Дело в том, что нам все еще нужно пройти дальше по последовательности numsи проверить, не осталось ли что-то — если мы ничего не получим дальше, только тогда мы будем знать, что мы закончили.

Короче говоря, нам нужно сделать еще один шаг, чтобы подтвердить конец nums.

Аналогично, вызов iter.next()в четвертый раз возвращает объект, заключающий четвертое значение в nums. Поскольку четвертого значения в нет nums, valueсвойство есть undefinedи doneесть true.

iter.next(); // {value: undefined, done: true}
Это означает, что iterдостигнут конец numsи, следовательно, нет необходимости повторять дальнейшие действия.

Несмотря на это, последующие вызовы iter.next()не возвращают nullили не возвращают пустой объект; но скорее они возвращают тот же объект, что и раньше, с valueравным undefinedи doneравным true.

iter.next(); // {value: undefined, done: true}
iter.next(); // {value: undefined, done: true}
iter.next(); // {value: undefined, done: true}
Вот как работает простой итератор.

Теперь пришло время вам реализовать все это по-настоящему, создав функцию makeIterator(), которая принимает массив и позволяет выполнять итерацию по нему, как показано выше.

Создайте функцию makeIterator(), которая принимает массив и возвращает итератор для его перебора.

С вашей функцией следующий код должен работать, как обсуждалось выше:

var nums = [1, 5, 16];
var iter = makeIterator(nums);

iter.next(); // {value: 1, done: false}
iter.next(); // {value: 5, done: false}
iter.next(); // {value: 16, done: false}
iter.next(); // {value: undefined, done: true}

Предопределенные итераторы
Если бы вы решили задачу выше, то наверняка поняли бы, что построить алгоритм, порождающий итератор, непросто.

Для этого нам нужны сложные навыки и понимание таких понятий, как лексическая область видимости, переменные замыкания, чтобы иметь возможность плавно построить алгоритм.

Но хорошая новость заключается в том, что нам не нужно создавать итераторы для многих классов данных в JavaScript — они имеют свой собственный определенный механизм для создания объектов итераторов и аналогичным образом используют итераторы для перебора своих экземпляров.

Этот механизм и есть @@iterator()метод .

Поднимем дискуссию....

Многие классы, такие как Array, String, ArrayBufferView, и HTMLCollectionт. д., определяют специальный метод для своих соответствующих объектов-прототипов, который можно вызывать для получения итератора для экземпляров этого класса.

Этот метод и есть @@iterator()метод.

Как вы знаете из главы «Символы», @@означает, что речь идет об общеизвестном символе — свойстве, определенном на Symbolобъекте.

В данном случае @@iteratorозначает, что мы имеем в виду Symbol.iterator.

Другими словами, мы также можем называть этот метод [Symbol.iterator]()методом.

В любом случае, @@iterator()метод, определенный в прототипе, например, Array.prototype возвращает объект итератора для соответствующего экземпляра ( Arrayв данном случае объект).

Этот объект итератора можно использовать точно так же, как мы использовали итераторы в разделе выше.

На самом деле все итераторы работают одинаково, несмотря ни на что - если они являются итераторами, это косвенно означает, что они следуют протоколу итератора и также будут работать синонимично друг другу.

Если итератор не работает, как все итераторы, то он просто не следует протоколу итератора и, следовательно, НЕ является итератором!
Ниже мы демонстрируем пример с использованием нашего старого numsмассива:

var nums = [1, 5, 16];

var iter = nums[Symbol.iterator]();

iter.next(); // {value: 1, done: false}
iter.next(); // {value: 5, done: false}
iter.next(); // {value: 16, done: false}
iter.next(); // {value: undefined, done: true}
Самая важная строка здесь — вторая строка, в которой мы получаем объект итератора из предопределенного @@iterator()метода массива.

Давайте разбираться, что здесь происходит.

Объявляется переменная iterи ей присваивается выражение. Это выражение есть nums[Symbol.iterator](). Способ его оценки описывается следующим образом:

Возвращает Symbol.iteratorсимвол, который затем сначала ищется в numsобъекте (помните, что массив также является объектом и, следовательно, также может иметь свойства).
Поскольку совпадения для символа на не найдено nums, поиск переходит к прототипу, numsт.е. к Array.prototypeобъекту.
Здесь действительно обнаруживается свойство символа - Symbol.iterator- и оно имеет функциональное значение. Другими словами, это метод, определенный в прототипе.
Наконец, этот метод вызывается, в результате чего возвращается объект итератора. Этот итератор сохраняется iter, и поэтому выполнение строки 2 завершается.
Имея итератор в руках, мы можем использовать его любым способом для повторения nums.

Метод @@iterator\_
Полезно знать, что многие классы в JavaScript имеют предопределенные методы порождения итераторов, определенные для них, благодаря свойству, ключом которого является значение Symbol.iterator(отсюда и название @@iterator).

Но было бы еще лучше, если бы мы могли как-то понять, что стоит за этой символической собственностью.

Почему у всех итерируемых объектов, таких как массивы и строки, итераторы скрыты за этим методом? В чем правда @@iterator()метода?

Ну это короткая история...

Любая конструкция, для которой требуется итерируемый объект , такой как for...ofцикл или оператор распространения ..., вызывает @@iterator()метод, определенный для итерируемого объекта.
Это соглашение установлено JavaScript, или, если быть более точным, ECMAScript 6.

Вам нужно перебрать последовательность — вам нужно вызвать для @@iterator()нее метод и использовать возвращенный итератор для своей работы.

Такой простой!

Но вы можете подумать, почему мы используем символическое свойство для этой цели. Почему мы не можем просто использовать строковое свойство, такое как iterator?

Что ж, определенно нет проблем с использованием строкового свойства, такого как iteratorили что-то еще, в этих строках. Однако JavaScript считает символы полезными в тех случаях, когда он хочет применить только один способ сделать что-то и когда он хочет изобразить что-то как приватное .
Рассмотрим пример.

В предыдущей главе мы видели, как for...ofработает цикл, когда ему дается последовательность для повторения. Теперь мы поймем, как именно он это делает. Ага, точно!

Рассмотрим код ниже:

var nums = [1, 5, 16];

for (var num of nums) {
console.log(num);
}
Мы все знаем, к чему бы это привело.

1
5
16
Чтобы понять, как работает for...ofцикл на базовом уровне, обратитесь к главе « Введение в итерацию JavaScript» .
Если серьезно, рассмотрите следующий код, который показывает, что происходит за кулисами, когда мы выполняем for...ofописанный выше цикл:

var nums = [1, 5, 16];

for (
// initialisation
var iter = nums[Symbol.iterator](),
next = iter.next(),
num = next.value;

// iterative check
!next.done;

// iterative expressions
next = iter.next(),
num = next.value
)

{
console.log(num);
}
В фоновом режиме это for...ofпревращается в простой forцикл.

Сначала этот цикл вызывает @@iteratorметод nums(в строке 5), а затем использует возвращенный итератор для итерации по нему (итератор сохраняется в iter).

После этого он вызывает next()метод iter(в строке 6) и сохраняет его значение в одноименной переменной next. nextбудет использоваться для получения свойств valueи .done

Поскольку num(будьте осторожны, мы не имеем в виду nums) соответствует каждому значению в numsнем присваивается valueсвойство next.

Кроме того, оператор итеративной проверки (в строке 7) просто означает, что цикл будет повторяться, если мы еще не закончили, т. е. если doneесть false.

Этот чек тоже мог быть next.done === false.
Наконец, последние два оператора предназначены для сброса соответствующих значений ( nextи num) для следующей итерации.

Итак, вот что происходит, когда встречается for...ofпетля.

Давайте рассмотрим другой пример, на этот раз с использованием типизированного массива.

Ниже показан пример, взятый из задачи 2 в предыдущей главе. У нас есть Uint8Array3-байтовые значения - 15, 192, 16, которые мы записываем с помощью @@iterator()метода, определенного в прототипной цепочке типизированного массива.

var uint8 = new Uint8Array([15, 192, 16]);

for (var byte of uint8) {
console.log(byte.toString(16));
}
В фоновом режиме этот код преобразуется в следующее:

var uint8 = new Uint8Array([15, 192, 16]);

for (
// initialisation
var iter = uint8[Symbol.iterator](),
next = iter.next(),
byte = next.value;

// iterative check
!next.done;

// iterative expressions
next = iter.next(),
byte = next.value
)

{
console.log(byte);
}
Опять же, сначала итератор для uint8извлекается путем вызова для него @@iterator()метода; а затем этот итератор используется для получения первого значения в uint8, для начала.

После этого мы действуем так же, как и раньше — продолжая итерацию, если мы еще не закончили, и сбрасываем переменные , nextи byteуказываем на следующее значение в последовательности uint8.

Разве это не довольно просто?

Если вы так думаете, продолжайте и попробуйте выполнить задание ниже.

В разделе выше мы переопределили следующий for...ofкод, используя простой forцикл.

Теперь вам нужно переопределить его, используя whileцикл.

var nums = [1, 5, 16];

for (var num of nums) {
console.log(num);
}

Прежде чем закончить этот раздел, следует уточнить, что из-за того, что for...ofон преобразуется в цикл, который выполняет многочисленные next()вызовы, он определенно медленнее по сравнению с обычным forциклом.

Однако это снижение производительности незаметно — фактически, даже не ухудшение — для коротких последовательностей, подобных тем, которые мы видели выше. Даже последовательности с более чем сотнями или даже тысячами элементов не вызовут сбоев.

Это касается только последовательностей, содержащих более миллиона значений; где каждая доля секунды имеет значение!

Идем дальше...
Объекты-итераторы — это действительно мощная идея, родившаяся с появлением ES6, позволяющая легко и элегантно выполнять итерации заданных последовательностей.

Однако вся идея еще не завершена. В следующей главе, посвященной Iterables , мы завершаем оставшиеся части этой главы, определяя наши собственные @@iterator()методы и используя их для того, чтобы заданные объекты работали с for...of.

А после этого мы рассмотрим еще одну концепцию, тесно связанную с итераторами, а именно функции-генераторы. Вы наверняка влюбитесь в генераторы - вот какие они милые!

Короче говоря, итерация еще не закончена, но да, вы выполнили одну треть!
